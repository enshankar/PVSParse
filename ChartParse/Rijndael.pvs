Rijndael  : THEORY

  BEGIN

   IMPORTING bytevectors

   A, K, K0, K1, K2, K3: VAR byv[16]

   get(A)(i, j: below(4)): byte
    = A(i + 4 * j)

   IMPORTING hex

   SboxHex: hexstring =  "637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b27509832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cfd0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdbe0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9ee1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16"

   Sbox: byv[256] =
     (LET X = hex2bytestring(SboxHex)
      IN X`seq)

    byteSubst(A) : byv[16] =
      (LAMBDA (i:below(16)): Sbox(A(i)))

    shiftRow(A): byv[16]
     = (LAMBDA (k: below(16)):
         LET i = u16rem(k, 4),
             j = u16div(k, 4),
	     ij: below(16) = j + i,
	     l = u16rem(ij, 4)  %left-shift by i. How would Arsenal figure this out from A2.5?
          IN get(A)(i, l))

    T2(b: byte): byte =  %In A2.6, the else case is 2b xor 283, which overflows a byte!
      IF b < 128 THEN 2*b ELSE u8xor(u8plus(b, b), 27) ENDIF 

    T3(b: byte): byte =
      u8xor(T2(b), b)

    mixColumn(A): byv[16]
    = (LAMBDA (k: below(16)):
         LET i = u16rem(k, 4),
             j = u16div(k, 4)
          IN COND i = 0 -> u8xor(u8xor(u8xor(T2(get(A)(0, j)), T3(get(A)(1, j))), get(A)(2, j)), get(A)(3, j)),
	          i = 1 -> u8xor(u8xor(u8xor(get(A)(0, j), T2(get(A)(1, j))), T3(get(A)(2, j))), get(A)(3, j)),
		  i = 2 -> u8xor(u8xor(u8xor(get(A)(0, j), get(A)(1, j)), T2(get(A)(2, j))), T3(get(A)(3, j))),
		  ELSE  -> u8xor(u8xor(u8xor(T3(get(A)(0, j)), get(A)(1, j)), get(A)(2, j)), T2(get(A)(3, j)))
	     ENDCOND)

    roundkeyXOR(A, K): byv[16] %K is the round key
     = byvXOR(A, K)

    roundConst(r: below(11)): RECURSIVE byte
     = (IF r <= 1 THEN r
        ELSE T2(roundConst(r-1))
	ENDIF)
	MEASURE r

    nextRoundKey(K, (rconst: byte)): byv[16] = 
    LET roundConst = T2,
         K0: byv[4] = (LAMBDA (i : below(4)):
	        IF i = 0
	        THEN u8xor(u8xor(get(K)(0, 0), Sbox(get(K)(1, 3))), rconst)%wasteful recomputing of roundConst 
                ELSE u8xor(get(K)(i, 0), Sbox(get(K)(nrem(i + 1, 4), 3)))
                ENDIF),
         K1: byv[4] = (LAMBDA (i : below(4)): u8xor(get(K)(i, 1), K0(i))),
	 K2: byv[4] = (LAMBDA (i : below(4)): u8xor(get(K)(i, 2), K1(i))),
	 K3: byv[4] = (LAMBDA (i : below(4)): u8xor(get(K)(i, 3), K2(i)))
          IN (LAMBDA (i: below(16)):
	         IF i < 4 THEN K0(i)
		 ELSIF i < 8 THEN K1(i - 4)
		 ELSIF i < 12 THEN K2(i - 8)
	         ELSE K3(i - 12)
		      ENDIF)

   KK: VAR ARRAY[below(11) -> byv[16]]

   allKeys(KK, (rconst : byte), (i: below(11))): RECURSIVE ARRAY[below(11) -> byv[16]] =
     (IF i = 10
       THEN KK
       ELSE allKeys(KK WITH [(i + 1):= nextRoundKey(KK(i), rconst)], T2(rconst), i + 1)
       ENDIF)
       MEASURE 10 - i

   Rijndael_step(A, K): byv[16] =
    (LET A1 = byteSubst(A),
        A2 = shiftRow(A1),
        A3 = mixColumn(A2)
     IN roundkeyXOR(A3, K))
		      
   Rijndael_rec(A, KK, (i : below(11))): RECURSIVE byv[16] =
    (IF i >=  10 THEN roundkeyXOR(shiftRow(byteSubst(A)), KK(i))
     ELSIF i = 0 THEN Rijndael_rec(roundkeyXOR(A, KK(i)),
                                   KK,
				   i + 1)
     ELSE LET A4 = Rijndael_step(A, KK(i)) 
	    IN Rijndael_rec(A4, KK, i + 1)
    ENDIF)
    MEASURE 10 - i

   Rijndael(A, K):  byv[16] = Rijndael_rec(A, allKeys((LAMBDA (k: below(11)): K), 1, 0), 0)

   hex16(X: byv[16]): hexstring =
      bytestring2hexstring((# length := 16, seq := X #))

   test0RD: hexstring =
    (LET Input = hex2bytestring("3243f6a8885a308d313198a2e0370734"), 
           Cipher = hex2bytestring("2b7e151628aed2a6abf7158809cf4f3c"), 
	   Output = roundkeyXOR(Input`seq, Cipher`seq),
	   Outputbytestring =  (# length := 16, seq := Output #)
	   IN bytestring2hexstring(Outputbytestring))

   testRijndael1: hexstring
    = (LET Input = hex2bytestring("3243f6a8885a308d313198a2e0370734"), 
           Cipher = hex2bytestring("2b7e151628aed2a6abf7158809cf4f3c"), 
	   Output = Rijndael(Input`seq, Cipher`seq),
	   Outputbytestring =  (# length := 16, seq := Output #)
	   IN bytestring2hexstring(Outputbytestring))
   
  END Rijndael
