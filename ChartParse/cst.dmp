
%% PVS Version 7.1.0 - International Allegro CL Enterprise Edition 10.1 [64-bit Mac OS X (Intel)] (Jul 15, 2020 12:38)
%% 10.1 [64-bit Mac OS X (Intel)] (Jul 15, 2020 12:38)
$$$PVSHOME/.pvs.lisp
(in-package :pvs)


$$$arrayCount.pvs
arrayCount   [T: TYPE ]
		: THEORY

  BEGIN

  len: VAR nat

  P: VAR [T -> bool]

   arr(len): TYPE = [below(len) -> T]

   count(len)(P)(A : arr(len)): upto(len) =
     card({i : below(len) | P(A(i))})

   u, v: VAR T

   count_update0: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES  count(len)(P)(A WITH [(i) := u]) = count(len)(P)(A) + 1)

   count_update: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES count(len)(P)(A) < count(len)(P)(A WITH [(i) := u]))


   count_update1: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES count(len)(P)(A) < count(len)(P)(A WITH [(i) |-> u]))

   count_update2: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       P(A(i)) AND NOT P(u)
         IMPLIES count(len)(P)(A WITH [(i) := u]) < count(len)(P)(A))

   count_update3: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       P(A(i)) AND NOT P(u)
         IMPLIES count(len)(P)(A WITH [(i) |-> u]) < count(len)(P)(A))


  END arrayCount

$$$arrayCount.prf
(arrayCount
 (count_TCC1 0
  (count_TCC1-1 nil 3798315575
   ("" (skeep)
    (("" (expand "is_finite")
      (("" (inst + "len" "id")
        (("" (typepred "id")
          (("" (expand "bijective?") (("" (ground) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (count subtype
          "{i: naturalnumbers.below(arrayCount.len) | arrayCount.P(arrayCount.A(i))}"
     "finite_set[below(len)]")))
 (count_TCC2 0
  (count_TCC2-1 nil 3798315575
   ("" (skeep)
    (("" (typepred "card[below(len)]({i: below(len) | P(A(i))})")
      (("1" (replace -1 :hide? t)
        (("1" (rewrite "Card_injection")
          (("1" (inst + "id")
            (("1" (typepred "id")
              (("1" (expand "bijective?") (("1" (ground) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "count_TCC1") nil nil))
      nil))
    nil)
   ((arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Card_injection formula-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil nat_types nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (count_TCC1 subtype-tcc nil arrayCount nil))
   nil
   (count subtype
          "finite_sets[naturalnumbers.below(arrayCount.len)].card({i: naturalnumbers.below(arrayCount.len) | arrayCount.P(arrayCount.A(i))})"
     "naturalnumbers.upto(arrayCount.len)")))
 (count_update0 0
  (count_update0-1 nil 3804561128
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_add formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_subset formula-decl nil finite_sets nil)
    (TRUE const-decl "bool" booleans nil)
    (count const-decl "upto(len)" arrayCount nil))
   shostak))
 (count_update 0
  (count_update-1 nil 3798315577
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card_add formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   shostak))
 (count_update1 0
  (count_update1-1 nil 3799389970
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card_add formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   shostak))
 (count_update2 0
  (count_update2-1 nil 3799389749
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = remove(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_remove")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil))
   shostak))
 (count_update3 0
  (count_update3-1 nil 3799420828
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = remove(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_remove")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil))
   shostak)))


$$$cstopdown.pvs
cstopdown	: THEORY

  BEGIN

byte: TYPE = below(256)
strings(len: uint32): TYPE = [below(len) -> byte]
num_non_terminals: byte = 255
non_terminal: TYPE = below(num_non_terminals)



ent: DATATYPE
  BEGIN
  fail: fail?
  pending: pending?
  loop: loop?
  good(span: uint32): good?
  push(pos: uint32, nt: uint8): push?
  END ent

peg  : DATATYPE
  BEGIN
   epsilon : epsilon?
   failure : failure?
   any(p : [byte -> bool]) : any?
   terminal(a: byte) : terminal?
   concat(e1, e2: non_terminal) : concat?
   choice(e1, e2: non_terminal) : or?
   check(e: non_terminal) : and?
   neg(e: non_terminal) : not?
  END peg

len: VAR uint32 %the length of the input

JUDGEMENT upto(len) SUBTYPE_OF uint32
JUDGEMENT non_terminal SUBTYPE_OF uint8

%The scaffold entry can be fail, loop, good(span), or pending.
good_good_entry?(len, (pos: upto(len)))(x: (good?)): bool =  (pos + span(x) <= len)

%nt(x) = num_non_terminals at the end of the list. 
good_push_entry?(len)(x: ent): bool = (push?(x) AND pos(x) <= len AND nt(x) <= num_non_terminals)

good_entry?(len, (pos: upto(len)))(x: ent): bool =
    (good?(x) => good_good_entry?(len, pos)(x)) AND (push?(x) => good_push_entry?(len)(x))
    
scaffold(len) : TYPE = [pos: upto(len) -> [non_terminal -> (good_entry?(len, pos))]]

m, n: VAR non_terminal

loop_or_push?(e: ent): bool = (loop?(e) or push?(e))

lang_spec: TYPE = [non_terminal -> peg]

G: VAR lang_spec

good_fail?(len, G, (s: strings(len)))((A: scaffold(len)), (i : upto(len)), n): bool =
  (CASES G(n) OF
           any(p): i = len OR NOT p(s(i)),
           terminal(a): i = len OR a /= s(i),
           concat(n1, n2):  fail?(A(i)(n1)) OR
                             (good?(A(i)(n1)) AND 
  			      fail?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): fail?(A(i)(n1)) AND fail?(A(i)(n2)),
           check(n1): fail?(A(i)(n1)),
  	   neg(n1): good?(A(i)(n1)),
  	   failure: TRUE
           ELSE FALSE
       ENDCASES)

instack(len, (A : scaffold(len)))(pos: upto(len), nt: non_terminal):  bool =
   push?(A(pos)(nt))

f: VAR {g : [(push?) -> uint64] | FORALL (x : (push?)): nt(x) = num_non_terminals IMPLIES g(x) = 0}

successor(len, G, (A: scaffold(len)))(entry1, entry2: (good_push_entry?(len))): bool =
  (LET p1 = pos(entry1),
       nt1 = nt(entry1),
       p2 = pos(entry2),
       nt2 = nt(entry2)
     IN nt1 >= num_non_terminals
        OR CASES G(nt1) OF
           concat(n1, n2):  (p2 = p1 AND nt2 = n1) OR
	                   (good?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1 + span(A(p1)(n1))),
           choice(n1, n2): (p2 = p1 AND nt2 = n1) OR
	                   (fail?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1),
           check(n1): (nt2 = n1 AND p2 = p1),
  	   neg(n1): (nt2 = n1 AND p2 = p1)
           ELSE FALSE
	   ENDCASES)

depth: VAR uint64

root, stack: VAR (push?)


good_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_push_entry?(len))):
   RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN depth = 0
     ELSE LET entry = A(pos(stack))(nt(stack))
	    IN good_push_entry?(len)(entry)
	       AND (nt(entry) = num_non_terminals OR successor(len, G, A)(entry, stack))
	            AND depth > 1 AND 
	              good_stack?(len, G, depth - 1, A)(entry)
    ENDIF)
    MEASURE depth

mem_stack?(len, G, depth, (A : scaffold(len)))(entry: (good_push_entry?(len)), stack: (good_stack?(len, G, depth, A))): RECURSIVE bool
 = (IF nt(stack) >= num_non_terminals
     THEN FALSE
     ELSE entry = stack OR mem_stack?(len, G, depth - 1, A)(entry, A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

good_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, stack: (good_push_entry?(len))), (u: (good_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   good_push_entry?(len)(entry) AND nt(entry) < num_non_terminals AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push?(A(pos(entry))(nt(entry)))
   IMPLIES good_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(stack))

fine_stack?(len, G, depth, (A: scaffold(len)))(stack: (good_stack?(len, G, depth, A))): RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN TRUE
     ELSE LET rest = A(pos(stack))(nt(stack))
          IN NOT mem_stack?(len, G, depth - 1, A)(stack, rest) AND
             fine_stack?(len, G, depth - 1, A)(A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

loop_ready?(len, G, (A: scaffold(len)), (i: upto(len)), n): bool =
   (CASES G(n) OF
           concat(n1, n2):  loop_or_push?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop_or_push?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop_or_push?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop_or_push?(A(i)(n2))),
           check(n1): loop_or_push?(A(i)(n1)),
  	   neg(n1): loop_or_push?(A(i)(n1))
           ELSE FALSE
       ENDCASES)
   				       

good_loop?(len, G)(A: scaffold(len), (i: upto(len)), n): bool =
(CASES G(n) OF
           concat(n1, n2):  loop?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop?(A(i)(n2))),
           check(n1): loop?(A(i)(n1)),
  	   neg(n1): loop?(A(i)(n1))
           ELSE FALSE
       ENDCASES)

good_good?(len, G, (s: strings(len)))((A: scaffold(len)), (i: upto(len)), n, (sp :upto(len - i))): bool =
 (CASES G(n) OF
         epsilon: sp = 0,
  	 any(p): sp = 1 AND p(s(i)),
  	 terminal(a): sp = 1 AND s(i) = a,
  	 concat(n1, n2): good?(A(i)(n1)) 
  	                 AND good?(A(i + span(A(i)(n1)))(n2)),
  	 choice(n1, n2): good?(A(i)(n1)) OR (fail?(A(i)(n1)) AND good?(A(i)(n2))),
  	 check(n1): good?(A(i)(n1)) AND sp = 0,
  	 neg(n1): fail?(A(i)(n1)) AND sp = 0,
  	 failure: FALSE
  	 ENDCASES)


good_tscaffold?(len, G, (s: strings(len)))(A : scaffold(len)): bool =
 (FORALL (i: upto(len)), n:
   CASES A(i)(n) OF
    fail: good_fail?(len, G, s)(A, i, n),
    loop: loop_ready?(len, G, A,  i, n), %don't need good_loop?
    good(sp):  sp <= len - i AND good_good?(len, G, s)(A, i, n, sp)
    ELSE TRUE
    ENDCASES)


% full_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_stack?(len, G, depth, A))): bool =
%    (FORALL (pos: upto(len)), m : instack(len, A)(pos, m) => mem_stack?(len, G, depth, A)(push(pos, m), stack))

IMPORTING  arrayCount
IMPORTING reals@sigma

good_depth?(len, (A : scaffold(len)))(depth: uint64): bool =
  (sigma(0, len, LAMBDA (i: upto(len)) : count(num_non_terminals)(push?)(A(i))) = depth)

sigma_nat: JUDGEMENT
      sigma(0, (i: upto(len)), (F: [upto(len) -> nat])) HAS_TYPE nat

sigma_pos: LEMMA
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         F(i) > 0 AND j >= i IMPLIES sigma(0, j, F) > 0)



good_root?(len, (A: scaffold(len)))((rootpos: upto(len)), rootnt : non_terminal): bool =
  (NOT pending?(A(rootpos)(rootnt)))

fine_scaffold?(len, G, (s: strings(len)))((rootpos : upto(len)), (rootnt: non_terminal))(A : scaffold(len)): bool =
         good_root?(len, A)(rootpos, rootnt) AND
   good_tscaffold?(len, G, s)(A)

   

state(len, G, (s: strings(len)), (rootpos: upto(len)), (rootnt: non_terminal)): TYPE
    = [# scaf: (fine_scaffold?(len, G, s)(rootpos, rootnt)), 
         depth: (good_depth?(len, scaf)),
	 stack: (fine_stack?(len, G, depth, scaf)),
	 lflag: {b: bool | IF b
	                     THEN nt(stack) = num_non_terminals OR loop_ready?(len, G, scaf, pos(stack), nt(stack))
			     ELSE (FORALL (i: upto(len)), n: NOT loop?(scaf(i)(n))) ENDIF}
	#]
         

empty?(stack): bool = (nt(stack) = num_non_terminals)

% putstack(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St: state(len, G, s, start, root) | NOT empty?(St`stack))((pos: upto(len)), (n| (pending?(St`scaf(pos)(n)) OR push?(St`scaf(pos)(n))) AND successor(len, G, St`scaf)(St`stack, push(pos, n))))
%    : state(len, G, s, start, root)
%  = (IF instack(len, St`scaf)(pos, n)
%        THEN St WITH [`scaf(pos)(n) := loop]
%        ELSE St WITH [`stack := push(pos, n), depth := St`depth + 1, `scaf(pos)(n) := St`stack]
%        ENDIF)

step(len, G, (s: strings(len)), (start: upto(len)), (rootnt: non_terminal))(St : state(len, G, s, start, rootnt)): state(len, G, s, start, rootnt)
 = (LET scaf = St`scaf,
	stack = St`stack,
	depth = St`depth,
	lflag = St`lflag
     IN
    IF empty?(stack)
    THEN St
    ELSE LET pos = pos(stack),
             cur = nt(stack),
	     rest = scaf(pos)(cur)
	  IN CASES G(cur) OF
            epsilon: St WITH [`scaf(pos)(cur) := good(0), `stack := rest, `depth := depth - 1],
	    failure: St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
	    any(p): (LET v = IF pos = len OR NOT p(s(pos)) THEN fail ELSE good(1) ENDIF
	           IN St WITH [`scaf(pos)(cur) := v, `stack := rest, `depth := depth - 1]),
            terminal(a): (LET v = IF pos = len OR a /= s(pos) THEN fail ELSE good(1) ENDIF
	                   IN St WITH [`scaf(pos)(cur) := v, `stack := rest, `depth := depth - 1]),
            concat(n1, n2): (CASES St`scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
			      good(sp): CASES St`scaf(pos + sp)(n2) OF
			                   fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
					   good(sp2): St WITH [`scaf(pos)(cur) := good(sp + sp2), `stack := rest, `depth := depth - 1],
					   pending: St WITH [`stack := push(pos + sp, n2), `depth := St`depth + 1, `scaf(pos+sp)(n2) := St`stack]
					   ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
					ENDCASES,
			      pending: St WITH [`stack := push(pos, n1), depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    choice(n1, n2): (CASES scaf(pos)(n1) OF
	                      fail: CASES scaf(pos)(n2) OF
			                   fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
					   good(sp): St WITH [`scaf(pos)(cur) := good(sp), `stack := rest, `depth := depth - 1],
					   pending: St WITH [`stack := push(pos, n2), `depth := depth + 1, `scaf(pos)(n2) := stack]
					   ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
					ENDCASES,
			      good(sp): St WITH [`scaf(pos)(cur) := good(sp), `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    check(n1): (CASES scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
			      good(sp): St WITH [`scaf(pos)(cur) := good(0), `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    neg(n1): (CASES scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := good(0), `stack := rest, `depth := depth - 1],
			      good(sp): St WITH [`scaf(pos)(cur) := fail, `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES)
          ENDCASES			      
    ENDIF)

IMPORTING lex4, arrayCount


%cmember(len)(l: list[stackentry(len)])(pn: stackentry(len)): bool = member(pn, l)

% membership_update: LEMMA
%    (FORALL (a: non_terminal), (l: list[non_terminal]): 
%       count(num_non_terminals)(id[bool])(cmember(cons(a, l))) =
%       count(num_non_terminals)(id[bool])(cmember(l) WITH [(a) := TRUE]))


 size(len, G, (s: strings(len)), pos: upto(len), n)(St : state(len, G, s, pos, n)): ordinal
 %=
   % lex2(count[entry](num_non_terminals)(pending?)(St`scaf(St`pos)),
   %      num_non_terminals - count[bool](num_non_terminals)(id)(cmember(St`stack)))

% size_putstack:
%   JUDGEMENT putstack(len, G, (s: strings(len)))(St: state(len, G, s) | NOT null?(St`stack))(n | pending?(St`scaf(St`pos)(n)))
%    HAS_TYPE {St1: state(len, G, s) | size(len, G, s)(St1) < size(len, G, s)(St)}

% size_step: LEMMA
%  FORALL len, G, (s: strings(len)), (St: state(len, G, s)): 
%    NOT (St`pos = 0 AND St`root = num_non_terminals)
%    IMPLIES size(len, G, s)(step(len, G, s)(St)) < size(len, G, s)(St)

 endstate(len, G, (s: strings(len))): TYPE =
    state(len, G, s, 0, num_non_terminals)

 parse(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St : state(len, G, s, start, root)): RECURSIVE endstate(len, G, s)
  = (IF NOT pending?(St`scaf(start)(root))
      THEN St
      ELSE parse(len, G, s, start, root)(step(len, G, s, start, root)(St))
      ENDIF)
      MEASURE size(len, G, s, start, root)(St) BY <

 doparse(len, G, (s: strings(len)), n): ent
   = (LET pend = (LAMBDA n: pending),
          St: state(len, G, s, 0, n) = (# 
 		 stack := push(0, n),
		 depth := 1,
 		 scaf := (LAMBDA (i: upto(len)): pend) WITH [(0)(n) := push(0, num_non_terminals)],
		 lflag := FALSE #)
      IN parse(len, G, s, 0, n)(St)`scaf(0)(n))
       
  END cstopdown

$$$cstopdown.prf
(cstopdown
 (subtype_TCC1 0
  (subtype_TCC1-1 nil 3804536638 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (subtype_ subtype "cstopdown.x" "uint32")))
 (subtype_TCC2 0
  (subtype_TCC2-1 nil 3804564519 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (exp2 def-decl "posnat" exp2 nil))
   nil (subtype_ subtype "cstopdown.x" "uint8")))
 (good_fail?_TCC1 0
  (good_fail?_TCC1-1 nil 3804455654 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "cstopdown.i"
    "naturalnumbers.below(cstopdown.len)")))
 (good_fail?_TCC2 0
  (good_fail?_TCC2-1 nil 3804455654 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "cstopdown.i"
    "naturalnumbers.below(cstopdown.len)")))
 (good_fail?_TCC3 0
  (good_fail?_TCC3-1 nil 3804455654
   ("" (grind)
    (("" (typepred "A!1(i!1)(n1!1)") (("" (grind) nil nil)) nil)) nil)
   ((ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype
    "(number_fields.+)(cstopdown.i, cstopdown.span(cstopdown.A(cstopdown.i)(cstopdown.n1)))"
    "naturalnumbers.upto(cstopdown.len)")))
 (successor_TCC1 0
  (successor_TCC1-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "cstopdown.entry1" "(cstopdown.push?)")))
 (successor_TCC2 0
  (successor_TCC2-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "cstopdown.entry2" "(cstopdown.push?)")))
 (successor_TCC3 0
  (successor_TCC1-1 nil 3804547853 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "cstopdown.nt1" "non_terminal")))
 (successor_TCC4 0
  (successor_TCC1-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (successor subtype "cstopdown.p1"
    "naturalnumbers.upto(cstopdown.len)")))
 (successor_TCC5 0
  (successor_TCC2-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (successor subtype "cstopdown.p1"
    "naturalnumbers.upto(cstopdown.len)")))
 (good_stack?_TCC1 0
  (good_stack?_TCC1-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_stack? subtype "cstopdown.stack" "(cstopdown.push?)")))
 (good_stack?_TCC2 0
  (good_stack?_TCC2-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_stack? subtype "cstopdown.entry" "(cstopdown.push?)")))
 (good_stack?_TCC3 0
  (good_stack?_TCC3-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "(number_fields.-)(cstopdown.depth, 1)"
    "uint64")))
 (good_stack?_TCC4 0
  (good_stack?_TCC4-1 nil 3804455654 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? termination
    "cstopdown.good_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A)"
    "nil")))
 (good_stack?_TCC5 0
  (good_stack?_TCC5-1 nil 3804547853 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "cstopdown.nt(cstopdown.stack)"
    "non_terminal")))
 (good_stack?_TCC6 0
  (good_stack?_TCC5-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "cstopdown.pos(cstopdown.stack)"
    "naturalnumbers.upto(cstopdown.len)")))
 (mem_stack?_TCC1 0
  (mem_stack?_TCC1-1 nil 3804455654
   ("" (skeep* :preds? t)
    (("" (expand "good_stack?") (("" (ground) nil nil)) nil)) nil)
   ((good_stack? def-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? subtype "(number_fields.-)(cstopdown.depth, 1)"
    "uint64")))
 (mem_stack?_TCC2 0
  (mem_stack?_TCC2-1 nil 3804455654 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? termination
    "cstopdown.mem_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A)"
    "nil")))
 (mem_stack?_TCC3 0
  (mem_stack?_TCC3-1 nil 3804455654 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil) (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (successor const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? subtype
    "cstopdown.A(cstopdown.pos(cstopdown.stack))(cstopdown.nt(cstopdown.stack))"
    "(cstopdown.good_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A))")))
 (good_mem_stack_TCC1 0
  (good_mem_stack_TCC1-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_mem_stack subtype "cstopdown.entry" "(cstopdown.push?)")))
 (good_mem_stack_TCC2 0
  (good_mem_stack_TCC1-1 nil 3804823614 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack subtype "(cstopdown.pos(cstopdown.entry))"
    "naturalnumbers.upto(cstopdown.len)")))
 (good_mem_stack 0
  (good_mem_stack-1 nil 3804823624
   ("" (induct "depth")
    (("1" (lazy-grind) nil nil)
     ("2" (grind)
      (("1" (expand "good_stack?") (("1" (propax) nil nil)) nil)
       ("2" (grind)
        (("2" (expand "good_stack?") (("2" (propax) nil nil)) nil))
        nil)
       ("3" (expand "good_stack?") (("3" (propax) nil nil)) nil))
      nil)
     ("3" (skeep*)
      (("3" (expand "mem_stack?" +)
        (("3" (ground)
          (("1" (typepred stack) (("1" (grind :if-match nil) nil nil))
            nil)
           ("2" (typepred stack) (("2" (grind :if-match nil) nil nil))
            nil)
           ("3" (expand "good_stack?" :fnum (-3 5))
            (("3" (ground)
              (("1" (hide -3 -6 5)
                (("1" (grind)
                  (("1" (apply-extensionality 4) nil nil)
                   ("2" (apply-extensionality 4) nil nil))
                  nil))
                nil)
               ("2" (hide -3 -6 2 6)
                (("2" (apply-extensionality 4) (("2" (grind) nil nil))
                  nil))
                nil)
               ("3" (inst?)
                (("3" (ground)
                  (("1" (hide 2)
                    (("1" (apply-extensionality 4)
                      (("1" (grind) nil nil)) nil))
                    nil)
                   ("2" (apply-extensionality 4)
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil)
               ("4" (typepred "entry")
                (("4" (apply-extensionality 4)
                  (("4" (grind :if-match nil) nil nil)) nil))
                nil)
               ("5" (hide -3)
                (("5"
                  (case "pos(entry) = pos(stack)"
                    "nt(entry) = nt(stack)")
                  (("1" (assert)
                    (("1" (apply-extensionality 5) nil nil)) nil)
                   ("2" (assert)
                    (("2" (expand "successor")
                      (("2" (ground)
                        (("1" (ground)
                          (("1" (lift-if) (("1" (ground) nil nil)) nil)
                           ("2" (lift-if) (("2" (ground) nil nil)) nil)
                           ("3" (lift-if)
                            (("3" (ground)
                              (("3"
                                (lift-if)
                                (("3" (ground) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (lift-if)
                            (("4" (ground)
                              (("4"
                                (lift-if)
                                (("4" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (ground)
                          (("2" (lift-if) (("2" (ground) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (assert)
                    (("3" (expand "successor")
                      (("3" (ground)
                        (("3" (ground)
                          (("1" (lift-if)
                            (("1" (ground)
                              (("1"
                                (lift-if)
                                (("1" (ground) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (lift-if)
                            (("2" (ground)
                              (("2"
                                (lift-if)
                                (("2" (ground) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (lift-if)
                            (("3" (ground)
                              (("3"
                                (lift-if)
                                (("3" (ground) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (lift-if)
                            (("4" (ground)
                              (("4"
                                (lift-if)
                                (("4" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("6" (inst? :polarity? t)
                (("6" (ground)
                  (("1" (hide 2)
                    (("1" (lift-if)
                      (("1" (ground)
                        (("1" (ground)
                          (("1" (apply-extensionality 4) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (lift-if)
                    (("2" (ground)
                      (("2" (ground)
                        (("2" (apply-extensionality 4) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (hide 2)
      (("4" (skeep*)
        (("4" (typepred entry) (("4" (grind) nil nil)) nil)) nil))
      nil)
     ("5" (hide 2)
      (("5" (skeep*)
        (("5" (typepred entry) (("5" (grind) nil nil)) nil)) nil))
      nil)
     ("6" (hide 2)
      (("6" (skeep*)
        (("6" (typepred entry) (("6" (grind) nil nil)) nil)) nil))
      nil)
     ("7" (hide 2) (("7" (grind) nil nil)) nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ent_push_extensionality formula-decl nil cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" cstopdown nil)
    (<= const-decl "bool" reals nil)
    (uint64 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil))
   shostak))
 (fine_stack?_TCC1 0
  (fine_stack?_TCC1-1 nil 3804908888
   ("" (skeep*) (("" (typepred stack) (("" (grind) nil nil)) nil)) nil)
   ((good_stack? def-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint64 type-eq-decl nil integertypes nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (byte type-eq-decl nil cstopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" cstopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype "cstopdown.rest"
    "(cstopdown.good_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A))")))
 (fine_stack?_TCC2 0
  (fine_stack?_TCC2-1 nil 3804908888 ("" (subtype-tcc) nil nil) nil nil
   (fine_stack? subtype "(number_fields.-)(cstopdown.depth, 1)"
    "uint64")))
 (fine_stack?_TCC3 0
  (fine_stack?_TCC3-1 nil 3804908888
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "stack") (("1" (grind) nil nil)) nil)
       ("2" (typepred "stack") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" cstopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype
    "cstopdown.A(cstopdown.pos(cstopdown.stack))(cstopdown.nt(cstopdown.stack))"
    "(cstopdown.good_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A))")))
 (fine_stack?_TCC4 0
  (fine_stack?_TCC4-1 nil 3804908888 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? termination
    "cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.A)"
    "nil")))
 (loop_ready?_TCC1 0
  (loop_ready?_TCC1-1 nil 3804455654
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (byte type-eq-decl nil cstopdown nil)
    (< const-decl "bool" reals nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (loop_ready? subtype
    "(number_fields.+)(cstopdown.i, cstopdown.span(cstopdown.A(cstopdown.i)(cstopdown.n1)))"
    "naturalnumbers.upto(cstopdown.len)")))
 (good_loop?_TCC1 0
  (good_loop?_TCC1-1 nil 3804455654
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (byte type-eq-decl nil cstopdown nil)
    (< const-decl "bool" reals nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_loop? subtype
    "(number_fields.+)(cstopdown.i, cstopdown.span(cstopdown.A(cstopdown.i)(cstopdown.n1)))"
    "naturalnumbers.upto(cstopdown.len)")))
 (good_good?_TCC1 0
  (good_good?_TCC1-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (good_good? subtype "(number_fields.-)(cstopdown.len, cstopdown.i)"
    "nat")))
 (good_good?_TCC2 0
  (good_good?_TCC2-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "cstopdown.i"
    "naturalnumbers.below(cstopdown.len)")))
 (good_good?_TCC3 0
  (good_good?_TCC3-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "cstopdown.i"
    "naturalnumbers.below(cstopdown.len)")))
 (good_good?_TCC4 0
  (good_good?_TCC4-1 nil 3804455654
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (byte type-eq-decl nil cstopdown nil)
    (< const-decl "bool" reals nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype
    "(number_fields.+)(cstopdown.i, cstopdown.span(cstopdown.A(cstopdown.i)(cstopdown.n1)))"
    "naturalnumbers.upto(cstopdown.len)")))
 (good_depth?_TCC1 0
  (good_depth?_TCC1-1 nil 3804542663 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (good_depth? subtype "0" "T_low[upto(len)]")))
 (good_depth?_TCC2 0
  (good_depth?_TCC2-1 nil 3804542663 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (good_depth? subtype "cstopdown.len" "T_high[upto(len)]")))
 (good_depth?_TCC3 0
  (good_depth?_TCC4-1 nil 3804542663 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_depth? assuming
    "reals@sigma[naturalnumbers.upto(cstopdown.len)].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (state_TCC1 0
  (state_TCC1-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (state subtype "cstopdown.stack" "(cstopdown.push?)")))
 (state_TCC2 0
  (state_TCC1-1 nil 3804730988 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (state subtype "cstopdown.pos(cstopdown.stack)"
    "naturalnumbers.upto(cstopdown.len)")))
 (state_TCC3 0
  (state_TCC2-1 nil 3804730988 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (state subtype "cstopdown.nt(cstopdown.stack)" "non_terminal")))
 (step_TCC1 0
  (step_TCC66-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "cstopdown.stack" "(cstopdown.push?)")))
 (step_TCC2 0
  (step_TCC1-1 nil 3804547853 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "cstopdown.cur" "non_terminal")))
 (step_TCC3 0
  (step_TCC10-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.pos"
         "naturalnumbers.upto(cstopdown.len)")))
 (step_TCC4 0
  (step_TCC3-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "0" "uint32")))
 (step_TCC5 0
  (step_TCC4-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.good(0)"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC6 0
  (step_TCC5-1 nil 3804455654
   ("" (skeep*)
    (("" (typepred "scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("1" (hide -2) (("1" (grind) nil nil)) nil)
           ("2" (expand "good_tscaffold?")
            (("2" (skeep)
              (("2" (case "i = pos!1" "n = cur")
                (("1" (assert)
                  (("1" (expand "good_good?") (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (inst - "i" "n")
                    (("2" (typepred stack)
                      (("2" (case "loop?(St`scaf(i)(n))")
                        (("1" (typepred lflag)
                          (("1" (ground)
                            (("1" (inst?) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (inst?) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (inst?) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert)
                  (("3" (inst - "i" "n")
                    (("3" (typepred stack)
                      (("3" (case "loop?(St`scaf(i)(n))")
                        (("1" (typepred lflag)
                          (("1" (ground)
                            (("1" (inst?) nil nil)
                             ("2" (grind) nil nil)
                             ("3" (inst?) nil nil)
                             ("4" (grind) nil nil)
                             ("5" (inst?) nil nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fine_scaffold? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (byte type-eq-decl nil cstopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (successor const-decl "bool" cstopdown nil)
    (good_fail? const-decl "bool" cstopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (/= const-decl "boolean" notequal nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good? const-decl "bool" cstopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC7 0
  (step_TCC1-1 nil 3804455654
   ("" (skeep* :preds? t)
    (("" (split +)
      (("1" (expand "good_depth?") (("1" (postpone) nil nil)) nil)
       ("2" (assert) nil nil)
       ("3" (expand good_depth? -) (("3" (postpone) nil nil)) nil))
      nil))
    nil)
   nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC8 0
  (step_TCC2-1 nil 3804455654
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred rest)
        (("1" (typepred stack)
          (("1" (expand good_stack?) (("1" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (lemma good_mem_stack)
        (("2" (inst - G "depth - 1" len scaf stack rest "good(0)")
          (("1" (ground)
            (("1" (hide 2)
              (("1" (typepred stack)
                (("1" (expand good_stack? -)
                  (("1" (ground) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil)
             ("2" (typepred stack) (("2" (grind) nil nil)) nil)
             ("3" (postpone) nil nil)
             ("4" (typepred stack) (("4" (grind) nil nil)) nil))
            nil)
           ("2" (hide 2)
            (("2" (expand "good_entry?")
              (("2" (expand "good_good_entry?")
                (("2" (typepred stack) (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (postpone) nil nil))
          nil))
        nil)
       ("3" (postpone) nil nil))
      nil))
    nil)
   nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC9 0
  (step_TCC83-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)](i)(cstopdown.n))) ENDIF}")))
 (step_TCC10 0
  (step_TCC8-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC11 0
  (step_TCC9-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC12 0
  (step_TCC6-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC13 0
  (step_TCC7-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC14 0
  (step_TCC84-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC15 0
  (step_TCC16-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.pos"
         "naturalnumbers.below(cstopdown.len)")))
 (step_TCC16 0
  (step_TCC11-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "1" "uint32")))
 (step_TCC17 0
  (step_TCC14-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.v"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC18 0
  (step_TCC15-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC19 0
  (step_TCC12-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]))")))
 (step_TCC20 0
  (step_TCC13-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]))")))
 (step_TCC21 0
  (step_TCC89-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v](i)(cstopdown.n))) ENDIF}")))
 (step_TCC22 0
  (step_TCC44-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.pos"
         "naturalnumbers.below(cstopdown.len)")))
 (step_TCC23 0
  (step_TCC17-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (/= const-decl "boolean" notequal nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "1" "uint32")))
 (step_TCC24 0
  (step_TCC20-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (/= const-decl "boolean" notequal nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.v"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC25 0
  (step_TCC21-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC26 0
  (step_TCC18-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]))")))
 (step_TCC27 0
  (step_TCC19-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v]))")))
 (step_TCC28 0
  (step_TCC90-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.v](i)(cstopdown.n))) ENDIF}")))
 (step_TCC29 0
  (step_TCC24-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC30 0
  (step_TCC25-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC31 0
  (step_TCC22-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC32 0
  (step_TCC23-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC33 0
  (step_TCC95-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC34 0
  (step_TCC30-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.+)(cstopdown.pos, cstopdown.sp)"
         "naturalnumbers.upto(cstopdown.len)")))
 (step_TCC35 0
  (step_TCC33-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC36 0
  (step_TCC34-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC37 0
  (step_TCC31-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC38 0
  (step_TCC32-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC39 0
  (step_TCC96-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC40 0
  (step_TCC41-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.+)(cstopdown.sp, cstopdown.sp2)"
         "uint32")))
 (step_TCC41 0
  (step_TCC42-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.good((number_fields.+)(cstopdown.sp, cstopdown.sp2))"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC42 0
  (step_TCC43-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good((number_fields.+)(cstopdown.sp, cstopdown.sp2))]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC43 0
  (step_TCC39-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good((number_fields.+)(cstopdown.sp, cstopdown.sp2))]))")))
 (step_TCC44 0
  (step_TCC40-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good((number_fields.+)(cstopdown.sp, cstopdown.sp2))]))")))
 (step_TCC45 0
  (step_TCC81-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good((number_fields.+)(cstopdown.sp2, cstopdown.sp))], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good((number_fields.+)(cstopdown.sp2, cstopdown.sp))](i)(cstopdown.n))) ENDIF}")))
 (step_TCC46 0
  (step_TCC45-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   nil
   (step subtype "cstopdown.St`stack"
         "(cstopdown.good_entry?(cstopdown.len, (number_fields.+)(cstopdown.pos, cstopdown.sp)))")))
 (step_TCC47 0
  (step_TCC46-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "cstopdown.St`scaf WITH [((number_fields.+)(cstopdown.pos, cstopdown.sp))(cstopdown.n2) := cstopdown.St`stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC48 0
  (step_TCC49-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.+)(cstopdown.St`depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [((number_fields.+)(cstopdown.pos, cstopdown.sp))(cstopdown.n2) := cstopdown.St`stack]))")))
 (step_TCC49 0
  (step_TCC50-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.+)(cstopdown.pos, cstopdown.sp)"
         "uint32")))
 (step_TCC50 0
  (step_TCC65-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "cstopdown.push((number_fields.+)(cstopdown.pos, cstopdown.sp), cstopdown.n2)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.St`depth, 1), cstopdown.St`scaf WITH [((number_fields.+)(cstopdown.pos, cstopdown.sp))(cstopdown.n2) := cstopdown.St`stack]))")))
 (step_TCC51 0
  (step_TCC82-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n2 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [((number_fields.+)(cstopdown.pos, cstopdown.sp))(cstopdown.n2) := cstopdown.St`stack], (number_fields.+)(cstopdown.pos, cstopdown.sp), cstopdown.n2)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [((number_fields.+)(cstopdown.pos, cstopdown.sp))(cstopdown.n2) := cstopdown.St`stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC52 0
  (step_TCC28-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC53 0
  (step_TCC29-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC54 0
  (step_TCC26-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC55 0
  (step_TCC27-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC56 0
  (step_TCC103-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (step_TCC57 0
  (step_TCC95-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.stack"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC58 0
  (step_TCC77-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC59 0
  (step_TCC78-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.+)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC60 0
  (step_TCC94-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.push(cstopdown.pos, cstopdown.n1)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC61 0
  (step_TCC104-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n1 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack], cstopdown.pos, cstopdown.n1)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC62 0
  (step_TCC37-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC63 0
  (step_TCC38-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC64 0
  (step_TCC35-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC65 0
  (step_TCC36-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC66 0
  (step_TCC98-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (step_TCC67 0
  (step_TCC55-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC68 0
  (step_TCC56-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC69 0
  (step_TCC53-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC70 0
  (step_TCC54-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC71 0
  (step_TCC99-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC72 0
  (step_TCC63-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.good(cstopdown.sp)"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC73 0
  (step_TCC64-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC74 0
  (step_TCC61-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]))")))
 (step_TCC75 0
  (step_TCC62-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]))")))
 (step_TCC76 0
  (step_TCC116-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)](i)(cstopdown.n))) ENDIF}")))
 (step_TCC77 0
  (step_TCC91-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.stack"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC78 0
  (step_TCC111-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (successor const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n2) := cstopdown.stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC79 0
  (step_TCC112-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.+)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n2) := cstopdown.stack]))")))
 (step_TCC80 0
  (step_TCC78-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.push(cstopdown.pos, cstopdown.n2)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n2) := cstopdown.stack]))")))
 (step_TCC81 0
  (step_TCC117-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n2 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n2) := cstopdown.stack], cstopdown.pos, cstopdown.n2)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n2) := cstopdown.stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC82 0
  (step_TCC59-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC83 0
  (step_TCC60-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC84 0
  (step_TCC57-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC85 0
  (step_TCC58-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC86 0
  (step_TCC118-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (step_TCC87 0
  (step_TCC75-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.good(cstopdown.sp)"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC88 0
  (step_TCC76-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC89 0
  (step_TCC73-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]))")))
 (step_TCC90 0
  (step_TCC74-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)]))")))
 (step_TCC91 0
  (step_TCC119-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(cstopdown.sp)](i)(cstopdown.n))) ENDIF}")))
 (step_TCC92 0
  (step_TCC112-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.stack"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC93 0
  (step_TCC92-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC94 0
  (step_TCC93-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.+)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC95 0
  (step_TCC94-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.push(cstopdown.pos, cstopdown.n1)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC96 0
  (step_TCC125-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n1 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack], cstopdown.pos, cstopdown.n1)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC97 0
  (step_TCC71-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC98 0
  (step_TCC72-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC99 0
  (step_TCC69-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC100 0
  (step_TCC70-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC101 0
  (step_TCC126-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (step_TCC102 0
  (step_TCC83-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC103 0
  (step_TCC84-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC104 0
  (step_TCC107-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC105 0
  (step_TCC108-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC106 0
  (step_TCC127-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC107 0
  (step_TCC91-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "0" "uint32")))
 (step_TCC108 0
  (step_TCC92-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.good(0)"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC109 0
  (step_TCC93-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC110 0
  (step_TCC110-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC111 0
  (step_TCC111-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC112 0
  (step_TCC128-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)](i)(cstopdown.n))) ENDIF}")))
 (step_TCC113 0
  (step_TCC133-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.stack"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC114 0
  (step_TCC113-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC115 0
  (step_TCC114-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.+)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC116 0
  (step_TCC115-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.push(cstopdown.pos, cstopdown.n1)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC117 0
  (step_TCC137-1 nil 3804706560 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n1 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack], cstopdown.pos, cstopdown.n1)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC118 0
  (step_TCC87-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC119 0
  (step_TCC88-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC120 0
  (step_TCC85-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC121 0
  (step_TCC86-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC122 0
  (step_TCC138-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (step_TCC123 0
  (step_TCC100-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "0" "uint32")))
 (step_TCC124 0
  (step_TCC101-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.good(0)"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC125 0
  (step_TCC102-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC126 0
  (step_TCC123-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC127 0
  (step_TCC124-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)]))")))
 (step_TCC128 0
  (step_TCC139-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.good(0)](i)(cstopdown.n))) ENDIF}")))
 (step_TCC129 0
  (step_TCC109-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.fail"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC130 0
  (step_TCC110-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC131 0
  (step_TCC131-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC132 0
  (step_TCC132-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail]))")))
 (step_TCC133 0
  (step_TCC140-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.fail](i)(cstopdown.n))) ENDIF}")))
 (step_TCC134 0
  (step_TCC134-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (ent type-decl nil cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" cstopdown nil)
    (loop_ready? const-decl "bool" cstopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" cstopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" cstopdown nil)
    (state type-eq-decl nil cstopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.stack"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC135 0
  (step_TCC134-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC136 0
  (step_TCC135-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.+)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC137 0
  (step_TCC136-1 nil 3804706560 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.push(cstopdown.pos, cstopdown.n1)"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.+)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack]))")))
 (step_TCC138 0
  (step_TCC137-1 nil 3804730988 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n1 = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack], cstopdown.pos, cstopdown.n1)) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.n1) := cstopdown.stack](i)(cstopdown.n))) ENDIF}")))
 (step_TCC139 0
  (step_TCC105-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (empty? const-decl "bool" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "cstopdown.loop"
         "(cstopdown.good_entry?(cstopdown.len, cstopdown.pos))")))
 (step_TCC140 0
  (step_TCC106-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype
         "cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]"
         "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(cstopdown.start, cstopdown.rootnt))")))
 (step_TCC141 0
  (step_TCC103-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "(number_fields.-)(cstopdown.depth, 1)"
         "(cstopdown.good_depth?(cstopdown.len, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC142 0
  (step_TCC104-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "cstopdown.rest"
         "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, (number_fields.-)(cstopdown.depth, 1), cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop]))")))
 (step_TCC143 0
  (step_TCC142-1 nil 3804730988 ("" (subtype-tcc) nil nil) nil nil
   (step subtype "booleans.TRUE"
         "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.nt(cstopdown.rest) = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop], cstopdown.pos(cstopdown.rest), cstopdown.nt(cstopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(cstopdown.len)), n: (booleans.NOT)(cstopdown.loop?(cstopdown.St`scaf WITH [(cstopdown.pos)(cstopdown.cur) := cstopdown.loop](i)(cstopdown.n))) ENDIF}")))
 (endstate_TCC1 0
  (endstate_TCC1-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (endstate subtype "0" "naturalnumbers.upto(cstopdown.len)")))
 (endstate_TCC2 0
  (endstate_TCC2-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (endstate subtype "cstopdown.num_non_terminals" "non_terminal")))
 (parse_TCC1 0
  (parse_TCC1-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (parse subtype "0" "naturalnumbers.upto(cstopdown.len)")))
 (parse_TCC2 0
  (parse_TCC2-1 nil 3804904050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (parse subtype "cstopdown.stack" "(cstopdown.push?)")))
 (parse_TCC3 0
  (parse_TCC2-1 nil 3804730988 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (parse subtype "cstopdown.pos(cstopdown.stack)"
          "naturalnumbers.upto(cstopdown.len)")))
 (parse_TCC4 0
  (parse_TCC3-1 nil 3804730988 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (peg type-decl nil cstopdown nil)
    (lang_spec type-eq-decl nil cstopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (scaffold type-eq-decl nil cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_stack? def-decl "bool" cstopdown nil)
    (fine_stack? def-decl "bool" cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (parse subtype "cstopdown.nt(cstopdown.stack)" "non_terminal")))
 (parse_TCC5 0
  (parse_TCC2-1 nil 3804455654 ("" (well-founded-tcc) nil nil) nil nil
   (parse well-founded
          "restrict[[ordstruct_adt.ordstruct, ordstruct_adt.ordstruct], [ordinal, ordinal], booleans.bool].restrict(ordinals.<)"
          "nil")))
 (parse_TCC6 0
  (parse_TCC3-1 nil 3804455654 ("" (subtype-tcc) nil nil) nil nil
   (parse subtype "cstopdown.St"
          "cstopdown.endstate(cstopdown.len, cstopdown.G, cstopdown.s)")))
 (parse_TCC7 0
  (parse_TCC4-1 nil 3804455654 ("" (termination-tcc) nil nil) nil nil
   (parse termination
          "cstopdown.parse(cstopdown.len, cstopdown.G, cstopdown.s, cstopdown.start, cstopdown.root)(cstopdown.step(cstopdown.len, cstopdown.G, cstopdown.s, cstopdown.start, cstopdown.root)(cstopdown.St))"
          "nil")))
 (doparse_TCC1 0
  (doparse_TCC3-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "cstopdown.pend"
            "[non_terminal -> (cstopdown.good_entry?(cstopdown.len, cstopdown.i))]")))
 (doparse_TCC2 0
  (doparse_TCC2-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (doparse subtype "0" "uint32")))
 (doparse_TCC3 0
  (doparse_TCC4-1 nil 3804547853 ("" (subtype-tcc) nil nil) nil nil
   (doparse subtype "cstopdown.num_non_terminals" "uint8")))
 (doparse_TCC4 0
  (doparse_TCC4-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "cstopdown.push(0, cstopdown.num_non_terminals)"
            "(cstopdown.good_entry?(cstopdown.len, 0))")))
 (doparse_TCC5 0
  (doparse_TCC5-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (good_good_entry? const-decl "bool" cstopdown nil)
    (good_push_entry? const-decl "bool" cstopdown nil)
    (good_entry? const-decl "bool" cstopdown nil)
    (good_root? const-decl "bool" cstopdown nil)
    (good_tscaffold? const-decl "bool" cstopdown nil)
    (fine_scaffold? const-decl "bool" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype
            "(LAMBDA (i: naturalnumbers.upto(cstopdown.len)): cstopdown.pend) WITH [(0)(cstopdown.n) := cstopdown.push(0, cstopdown.num_non_terminals)]"
            "(cstopdown.fine_scaffold?(cstopdown.len, cstopdown.G, cstopdown.s)(0, cstopdown.n))")))
 (doparse_TCC6 0
  (doparse_TCC1-1 nil 3804455654 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "1"
            "(cstopdown.good_depth?(cstopdown.len, (LAMBDA (i: naturalnumbers.upto(cstopdown.len)): cstopdown.pend) WITH [(0)(cstopdown.n) := cstopdown.push(0, cstopdown.num_non_terminals)]))")))
 (doparse_TCC7 0
  (doparse_TCC6-1 nil 3804534082 ("" (subtype-tcc) nil nil) nil nil
   (doparse subtype "cstopdown.push(0, cstopdown.n)"
            "(cstopdown.fine_stack?(cstopdown.len, cstopdown.G, 1, (LAMBDA (i: naturalnumbers.upto(cstopdown.len)): cstopdown.pend) WITH [(0)(cstopdown.n) := cstopdown.push(0, cstopdown.num_non_terminals)]))")))
 (doparse_TCC8 0
  (doparse_TCC8-1 nil 3804730988 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil cstopdown nil)
    (non_terminal type-eq-decl nil cstopdown nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" cstopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "booleans.FALSE"
            "{b: booleans.bool | IF b THEN booleans.OR(cstopdown.n = cstopdown.num_non_terminals, cstopdown.loop_ready?(cstopdown.len, cstopdown.G, (LAMBDA (i: naturalnumbers.upto(cstopdown.len)): cstopdown.pend) WITH [(0)(cstopdown.n) := cstopdown.push(0, cstopdown.num_non_terminals)], 0, cstopdown.n)) ELSE FORALL (i_1: naturalnumbers.upto(cstopdown.len)), (n_1: cstopdown.non_terminal): (booleans.NOT)(cstopdown.loop?((LAMBDA (i: naturalnumbers.upto(cstopdown.len)): cstopdown.pend) WITH [(0)(cstopdown.n) := cstopdown.push(0, cstopdown.num_non_terminals)](i_1)(n_1))) ENDIF}"))))

