cstopdown	: THEORY

  BEGIN

byte: TYPE = below(256)
strings(len: uint32): TYPE = [below(len) -> byte]
num_non_terminals: byte = 255
non_terminal: TYPE = below(num_non_terminals)



ent: DATATYPE
  BEGIN
  fail(dep: uint64): fail?
  pending: pending?
  loop: loop?
  good(dep: uint64, span: uint32): good?
  push(pos: uint64, nt: uint8): push?
  END ent

peg  : DATATYPE
  BEGIN
   epsilon : epsilon?
   failure : failure?
   any(p : [byte -> bool]) : any?
   terminal(a: byte) : terminal?
   concat(e1, e2: non_terminal) : concat?
   choice(e1, e2: non_terminal) : or?
   check(e: non_terminal) : and?
   neg(e: non_terminal) : not?
  END peg

len: VAR uint32 %the length of the input

JUDGEMENT upto(len) SUBTYPE_OF uint32
JUDGEMENT non_terminal SUBTYPE_OF uint8

%The scaffold entry can be fail, loop, good(span), or pending.
good_good_entry?(len, (pos: upto(len)))(x: (good?)): bool =  (pos + span(x) <= len)

%nt(x) = num_non_terminals at the end of the list. 
good_push_entry?(len)(x: ent): bool = (push?(x) AND pos(x) <= len AND nt(x) <= num_non_terminals)

good_entry?(len, (pos: upto(len)))(x: ent): bool =
    (good?(x) => good_good_entry?(len, pos)(x)) AND (push?(x) => good_push_entry?(len)(x))
    
scaffold(len) : TYPE = [pos: upto(len) -> [non_terminal -> (good_entry?(len, pos))]]

m, n: VAR non_terminal

loop_or_push?(e: ent): bool = (loop?(e) or push?(e))

lang_spec: TYPE = [non_terminal -> peg]

G: VAR lang_spec

instack(len, (A : scaffold(len)))(pos: upto(len), nt: non_terminal):  bool =
   push?(A(pos)(nt))

f: VAR {g : [(push?) -> uint64] | FORALL (x : (push?)): nt(x) = num_non_terminals IMPLIES g(x) = 0}

successor(len, G, (A: scaffold(len)))(entry1, entry2: (good_push_entry?(len))): bool =
  (LET p1 = pos(entry1),
       nt1 = nt(entry1),
       p2 = pos(entry2),
       nt2 = nt(entry2)
     IN nt1 >= num_non_terminals
        OR CASES G(nt1) OF
           concat(n1, n2):  (p2 = p1 AND nt2 = n1) OR
	                   (good?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1 + span(A(p1)(n1))),
           choice(n1, n2): (p2 = p1 AND nt2 = n1) OR
	                   (fail?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1),
           check(n1): (nt2 = n1 AND p2 = p1),
  	   neg(n1): (nt2 = n1 AND p2 = p1)
           ELSE FALSE
	   ENDCASES)

depth: VAR uint64

root, stack: VAR (push?)


good_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_push_entry?(len))):
   RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN depth = 0
     ELSE LET entry = A(pos(stack))(nt(stack))
	    IN good_push_entry?(len)(entry)
	       AND (nt(entry) = num_non_terminals OR successor(len, G, A)(entry, stack))
	            AND depth > 1 AND 
	              good_stack?(len, G, depth - 1, A)(entry)
    ENDIF)
    MEASURE depth

mem_stack?(len, G, depth, (A : scaffold(len)))(entry: (good_push_entry?(len)), stack: (good_stack?(len, G, depth, A))): RECURSIVE bool
 = (IF nt(stack) >= num_non_terminals
     THEN FALSE
     ELSE entry = stack OR mem_stack?(len, G, depth - 1, A)(entry, A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

good_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, stack: (good_push_entry?(len))), (u: (good_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   good_push_entry?(len)(entry) AND nt(entry) < num_non_terminals AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push?(A(pos(entry))(nt(entry)))
   IMPLIES good_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(stack))

mem_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, v, stack: (good_push_entry?(len))), (u: (good_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   good_push_entry?(len)(entry) AND nt(entry) < num_non_terminals AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push?(A(pos(entry))(nt(entry)))
   IMPLIES mem_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(v, stack)
           = mem_stack?(len, G, depth, A)(v, stack))


fine_stack?(len, G, depth, (A: scaffold(len)))(stack: (good_stack?(len, G, depth, A))): RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN TRUE
     ELSE LET rest = A(pos(stack))(nt(stack))
          IN NOT mem_stack?(len, G, depth - 1, A)(stack, rest) AND
             fine_stack?(len, G, depth - 1, A)(A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

fine_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, stack: (good_push_entry?(len))), (u: (good_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   good_push_entry?(len)(entry) AND nt(entry) < num_non_terminals AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push?(A(pos(entry))(nt(entry)))
   IMPLIES fine_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(stack)
           = fine_stack?(len, G, depth, A)(stack))

dgood?(d: uint64, u: ent): bool = good?(u) AND dep(u) < d
dfail?(d: uint64, u: ent): bool = fail?(u) AND dep(u) < d

loop_ready?(len, G, (A: scaffold(len)), (i: upto(len)), n): bool =
   (CASES G(n) OF
           concat(n1, n2):  loop_or_push?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop_or_push?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop_or_push?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop_or_push?(A(i)(n2))),
           check(n1): loop_or_push?(A(i)(n1)),
  	   neg(n1): loop_or_push?(A(i)(n1))
           ELSE FALSE
       ENDCASES)
   				       
good_fail?(len, G, (s: strings(len)))((A: scaffold(len)), (i : upto(len)), n, (d: uint64)): bool =
  (CASES G(n) OF
           any(p): i = len OR NOT p(s(i)),
           terminal(a): i = len OR a /= s(i),
           concat(n1, n2):  dfail?(d, A(i)(n1)) OR
                             (dgood?(d, A(i)(n1)) AND 
  			      dfail?(d, A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): dfail?(d, A(i)(n1)) AND dfail?(d, A(i)(n2)),
           check(n1): dfail?(d, A(i)(n1)),
  	   neg(n1): dgood?(d, A(i)(n1)),
  	   failure: TRUE
           ELSE FALSE
       ENDCASES)

good_loop?(len, G)(A: scaffold(len), (i: upto(len)), n): bool =
(CASES G(n) OF
           concat(n1, n2):  loop?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop?(A(i)(n2))),
           check(n1): loop?(A(i)(n1)),
  	   neg(n1): loop?(A(i)(n1))
           ELSE FALSE
       ENDCASES)

good_good?(len, G, (s: strings(len)))((A: scaffold(len)), (i: upto(len)), n, (d: uint32), (sp :upto(len - i))): bool =
 (CASES G(n) OF
         epsilon: sp = 0,
  	 any(p): sp = 1 AND p(s(i)),
  	 terminal(a): sp = 1 AND s(i) = a,
  	 concat(n1, n2): dgood?(d, A(i)(n1)) 
  	                 AND dgood?(d, A(i + span(A(i)(n1)))(n2)),
  	 choice(n1, n2): dgood?(d, A(i)(n1)) OR (dfail?(d, A(i)(n1)) AND dgood?(d, A(i)(n2))),
  	 check(n1): dgood?(d, A(i)(n1)) AND sp = 0,
  	 neg(n1): dfail?(d, A(i)(n1)) AND sp = 0,
  	 failure: FALSE
  	 ENDCASES)

good_entry?(len, G, (s: strings(len)))(A : scaffold(len), (i : upto(len)), n, (u: ent)): bool =
   CASES u OF
    fail(d): good_fail?(len, G, s)(A, i, n, d),
    loop: loop_ready?(len, G, A,  i, n), %don't need good_loop?
    good(d, sp):  sp <= len - i AND good_good?(len, G, s)(A, i, n, d, sp)
    ELSE TRUE
    ENDCASES

fine_entry?(len, G, (s: strings(len)))(A : scaffold(len), (i : upto(len)), n, (u: ent)): bool =
   CASES u OF
    fail(d): good_fail?(len, G, s)(A, i, n, d),
    loop: loop_ready?(len, G, A,  i, n), %don't need good_loop?
    good(d, sp):  sp <= len - i AND good_good?(len, G, s)(A, i, n, d, sp)
    ELSE FALSE
    ENDCASES

good_tscaffold?(len, G, (s: strings(len)))(A : scaffold(len)): bool =
 (FORALL (i: upto(len)), n: good_entry?(len, G, s)(A, i, n, A(i)(n)))

% full_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_stack?(len, G, depth, A))): bool =
%    (FORALL (pos: upto(len)), m : instack(len, A)(pos, m) => mem_stack?(len, G, depth, A)(push(pos, m), stack))

IMPORTING  arrayCount
IMPORTING reals@sigma

good_depth?(len, (A : scaffold(len)))(depth: uint64): bool =
  (sigma(0, len, LAMBDA (i: upto(len)) : count(num_non_terminals)(push?)(A(i))) = depth)

sigma_nat: LEMMA
(FORALL (i: upto(len)), (F: [upto(len) -> nat]): 
      sigma(0, i, F) >= 0)

sigma_pos: LEMMA
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         F(i) > 0 AND j >= i IMPLIES sigma(0, j, F) > 0)

sigma_dec: LEMMA
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         F(i) > 0 IMPLIES 
         sigma(0, j, F WITH [(i) := F(i) - 1]) = (IF j < i THEN sigma(0, j, F) ELSE sigma(0, j, F) - 1 ENDIF))

sigma_inc: LEMMA 
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         sigma(0, j, F WITH [(i) := F(i) + 1]) = (IF j < i THEN sigma(0, j, F) ELSE sigma(0, j, F) + 1 ENDIF))

good_root?(len, (A: scaffold(len)))((rootpos: upto(len)), rootnt : non_terminal): bool =
  (NOT pending?(A(rootpos)(rootnt)))

fine_scaffold?(len, G, (s: strings(len)))((rootpos : upto(len)), (rootnt: non_terminal))(A : scaffold(len)): bool =
         good_root?(len, A)(rootpos, rootnt) AND
   good_tscaffold?(len, G, s)(A)

good_good_tscaffold: LEMMA
  (FORALL (s: strings(len)), (A: scaffold(len)), (entry: (good_push_entry?(len))), (u: (good_entry?(len, (pos(entry))))): 
   good_push_entry?(len)(entry) AND nt(entry) < num_non_terminals AND
   push?(A(pos(entry))(nt(entry))) AND
   good_tscaffold?(len, G, s)(A) AND
   fine_entry?(len, G, s)(A, pos(entry), nt(entry), u) AND
   (FORALL (j: upto(len)), m: loop?(A(j)(m)) IMPLIES loop_ready?(len, G, A, pos(entry), nt(entry)))
   IMPLIES good_tscaffold?(len, G, s)(A WITH [(pos(entry))(nt(entry)):= u]))

state(len, G, (s: strings(len)), (rootpos: upto(len)), (rootnt: non_terminal)): TYPE
    = [# scaf: (fine_scaffold?(len, G, s)(rootpos, rootnt)), 
         depth: (good_depth?(len, scaf)),
	 stack: (fine_stack?(len, G, depth, scaf)),
	 lflag: {b: bool | IF b
	                     THEN nt(stack) = num_non_terminals OR loop_ready?(len, G, scaf, pos(stack), nt(stack))
			     ELSE (FORALL (i: upto(len)), n: NOT loop?(scaf(i)(n))) ENDIF}
	#]
         

empty?(stack): bool = (nt(stack) = num_non_terminals)

% putstack(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St: state(len, G, s, start, root) | NOT empty?(St`stack))((pos: upto(len)), (n| (pending?(St`scaf(pos)(n)) OR push?(St`scaf(pos)(n))) AND successor(len, G, St`scaf)(St`stack, push(pos, n))))
%    : state(len, G, s, start, root)
%  = (IF instack(len, St`scaf)(pos, n)
%        THEN St WITH [`scaf(pos)(n) := loop]
%        ELSE St WITH [`stack := push(pos, n), depth := St`depth + 1, `scaf(pos)(n) := St`stack]
%        ENDIF)

step(len, G, (s: strings(len)), (start: upto(len)), (rootnt: non_terminal))(St : state(len, G, s, start, rootnt)): state(len, G, s, start, rootnt)
 = (LET scaf = St`scaf,
	stack = St`stack,
	depth = St`depth,
	lflag = St`lflag
     IN
    IF empty?(stack)
    THEN St
    ELSE LET pos = pos(stack),
             cur = nt(stack),
	     rest = scaf(pos)(cur)
	  IN CASES G(cur) OF
            epsilon: St WITH [`scaf(pos)(cur) := good(0, 0), `stack := rest, `depth := depth - 1],
	    failure: St WITH [`scaf(pos)(cur) := fail(0), `stack := rest, `depth := depth - 1],
	    any(p): (LET v = IF pos = len OR NOT p(s(pos)) THEN fail(0) ELSE good(0, 1) ENDIF
	           IN St WITH [`scaf(pos)(cur) := v, `stack := rest, `depth := depth - 1]),
            terminal(a): (LET v = IF pos = len OR a /= s(pos) THEN fail(0) ELSE good(0, 1) ENDIF
	                   IN St WITH [`scaf(pos)(cur) := v, `stack := rest, `depth := depth - 1]),
            concat(n1, n2): (CASES St`scaf(pos)(n1) OF
	                      fail(d1): St WITH [`scaf(pos)(cur) := fail(d1+1), `stack := rest, `depth := depth - 1],
			      good(d1, sp): CASES St`scaf(pos + sp)(n2) OF
			                   fail(d2): St WITH [`scaf(pos)(cur) := fail(d2+1), `stack := rest, `depth := depth - 1],
					   good(d2, sp2): St WITH [`scaf(pos)(cur) := good(1+max(d1, d2), sp + sp2), `stack := rest, `depth := depth - 1],
					   pending: St WITH [`stack := push(pos + sp, n2), `depth := St`depth + 1, `scaf(pos+sp)(n2) := St`stack]
					   ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
					ENDCASES,
			      pending: St WITH [`stack := push(pos, n1), depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    choice(n1, n2): (CASES scaf(pos)(n1) OF
	                      fail(d1): CASES scaf(pos)(n2) OF
			                   fail(d2): St WITH [`scaf(pos)(cur) := fail(max(d1,d2)+1), `stack := rest, `depth := depth - 1],
					   good(d2, sp): St WITH [`scaf(pos)(cur) := good(d2, sp), `stack := rest, `depth := depth - 1],
					   pending: St WITH [`stack := push(pos, n2), `depth := depth + 1, `scaf(pos)(n2) := stack]
					   ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
					ENDCASES,
			      good(d1, sp): St WITH [`scaf(pos)(cur) := good(d1+1, sp), `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    check(n1): (CASES scaf(pos)(n1) OF
	                      fail(d1): St WITH [`scaf(pos)(cur) := fail(d1+1), `stack := rest, `depth := depth - 1],
			      good(d1, sp): St WITH [`scaf(pos)(cur) := good(d1+1, 0), `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES),
	    neg(n1): (CASES scaf(pos)(n1) OF
	                      fail(d1): St WITH [`scaf(pos)(cur) := good(d1+1, 0), `stack := rest, `depth := depth - 1],
			      good(d1, sp): St WITH [`scaf(pos)(cur) := fail(d1+1), `stack := rest, `depth := depth - 1],
			      pending: St WITH [`stack := push(pos, n1), `depth := depth + 1, `scaf(pos)(n1) := stack]
			      ELSE St WITH [`scaf(pos)(cur) := loop, `depth := depth - 1, `stack := rest, lflag := TRUE]
			      ENDCASES)
          ENDCASES			      
    ENDIF)

IMPORTING lex4, arrayCount


%cmember(len)(l: list[stackentry(len)])(pn: stackentry(len)): bool = member(pn, l)

% membership_update: LEMMA
%    (FORALL (a: non_terminal), (l: list[non_terminal]): 
%       count(num_non_terminals)(id[bool])(cmember(cons(a, l))) =
%       count(num_non_terminals)(id[bool])(cmember(l) WITH [(a) := TRUE]))


 size(len, G, (s: strings(len)), pos: upto(len), n)(St : state(len, G, s, pos, n)): ordinal
 %=
   % lex2(count[entry](num_non_terminals)(pending?)(St`scaf(St`pos)),
   %      num_non_terminals - count[bool](num_non_terminals)(id)(cmember(St`stack)))

% size_putstack:
%   JUDGEMENT putstack(len, G, (s: strings(len)))(St: state(len, G, s) | NOT null?(St`stack))(n | pending?(St`scaf(St`pos)(n)))
%    HAS_TYPE {St1: state(len, G, s) | size(len, G, s)(St1) < size(len, G, s)(St)}

% size_step: LEMMA
%  FORALL len, G, (s: strings(len)), (St: state(len, G, s)): 
%    NOT (St`pos = 0 AND St`root = num_non_terminals)
%    IMPLIES size(len, G, s)(step(len, G, s)(St)) < size(len, G, s)(St)

 endstate(len, G, (s: strings(len))): TYPE =
    state(len, G, s, 0, num_non_terminals)

 parse(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St : state(len, G, s, start, root)): RECURSIVE endstate(len, G, s)
  = (IF St`depth = 0
      THEN St
      ELSE parse(len, G, s, start, root)(step(len, G, s, start, root)(St))
      ENDIF)
      MEASURE size(len, G, s, start, root)(St) BY <

 doparse(len, G, (s: strings(len)), n): ent
   = (LET pend = (LAMBDA n: pending),
          St: state(len, G, s, 0, n) = (# 
 		 stack := push(0, n),
		 depth := 1,
 		 scaf := (LAMBDA (i: upto(len)): pend) WITH [(0)(n) := push(0, num_non_terminals)],
		 lflag := FALSE #)
      IN parse(len, G, s, 0, n)(St)`scaf(0)(n))
       
  END cstopdown
