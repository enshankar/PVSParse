(ltepegproof
 (inqstack_TCC1 0
  (inqstack_TCC1-1 nil 3888202986 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[qstack])" ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (inqstack termination
    "ltepegproof.inqstack(ltepegproof.n, ltepegproof.i, ltepegproof.T)"
    "nil")))
 (stacksize_TCC1 0
  (stacksize_TCC1-1 nil 3888202986 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (<< adt-def-decl "(strict_well_founded?[qstack])" ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (stacksize termination "ltepegproof.stacksize(ltepegproof.T)"
    "nil")))
 (good_parsetree?_TCC1 0
  (good_parsetree?_TCC1-1 nil 3888202986 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[parsetree])" ltepegproof
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? termination
    "ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i, ltepegproof.Q)"
    "nil")))
 (good_parsetree?_TCC2 0
  (good_parsetree?_TCC6-1 nil 3888202986 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[parsetree])" ltepegproof
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? termination
    "ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i, ltepegproof.Q)"
    "nil")))
 (good_parsetree?_TCC3 0
  (good_parsetree?_TCC7-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype
    "(number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.entry(ltepegproof.Q)))"
    "{i | reals.<=(ltepegproof.i, ltepegproof.len)}")))
 (good_parsetree?_TCC4 0
  (good_parsetree?_TCC11-1 nil 3888202986
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (<< adt-def-decl "(strict_well_founded?[parsetree])" ltepegproof
     nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? termination
    "ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n2, (number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.entry(ltepegproof.Q))), ltepegproof.R)"
    "nil")))
 (good_parsetree?_TCC5 0
  (good_parsetree?_TCC2-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.E"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC6 0
  (good_parsetree?_TCC3-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.Q)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC7 0
  (good_parsetree?_TCC22-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.R)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC8 0
  (good_parsetree?_TCC4-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.E"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC9 0
  (good_parsetree?_TCC5-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.Q)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC10 0
  (good_parsetree?_TCC27-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.R)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC11 0
  (good_parsetree?_TCC14-1 nil 3888202986
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[parsetree])" ltepegproof
     nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? termination
    "ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n3, ltepegproof.i, ltepegproof.R)"
    "nil")))
 (good_parsetree?_TCC12 0
  (good_parsetree?_TCC12-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.E"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC13 0
  (good_parsetree?_TCC13-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.Q)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC14 0
  (good_parsetree?_TCC32-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.R)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC15 0
  (good_parsetree?_TCC15-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.E"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC16 0
  (good_parsetree?_TCC16-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.Q)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (good_parsetree?_TCC17 0
  (good_parsetree?_TCC36-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (good_parsetree? subtype "ltepegproof.entry(ltepegproof.R)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (buildtree_TCC1 0
  (buildtree_TCC1-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ent type-decl nil ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (buildtree_TCC2 0
  (buildtree_TCC2-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "z`9") (("" (grind) nil nil)) nil)) nil)
   ((loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (uint32 type-eq-decl nil integertypes nil)
    (qstack type-decl nil ltepegproof nil)
    (below type-eq-decl nil naturalnumbers nil)
    (prepeg type-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (state type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (strings type-eq-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (index type-eq-decl nil integertypes nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (buildtree subtype
    "ltepegproof.z`6`scaf(ltepegproof.z`9)(ltepegproof.z`8)"
    "{x: ltepeg.ent | booleans.OR(ltepeg.fail?(x), ltepeg.good?(x))}")))
 (buildtree_TCC3 0
  (buildtree_TCC5-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (flatten)
          (("" (expand good_tscaffold?)
            (("" (assert) (("" (inst?) (("" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))}")))
 (buildtree_TCC4 0
  (buildtree_TCC21-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (flatten)
          (("" (expand good_tscaffold?)
            (("" (inst?) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree termination
    "ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i)"
    "nil")))
 (buildtree_TCC5 0
  (buildtree_TCC3-1 nil 3888202986
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (expand "good_tscaffold?")
          (("" (flatten)
            (("" (inst-cp - i n)
              (("" (inst - i n1) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma def-decl "nat" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "(number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n2)))}")))
 (buildtree_TCC6 0
  (buildtree_TCC27-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (qstack type-decl nil ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree termination
    "ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n2, (number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1))))"
    "nil")))
 (buildtree_TCC7 0
  (buildtree_TCC4-1 nil 3888202986 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ent type-decl nil ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (span adt-accessor-decl "[(good?) -> uint32]" ltepeg nil)
    (good? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (defent type-eq-decl nil ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (qstack type-decl nil ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)" "defent")))
 (buildtree_TCC8 0
  (buildtree_TCC10-1 nil 3888202986
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst-cp - i n)
              (("" (inst - i n1) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma def-decl "nat" ltepeg nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.two(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n), ltepegproof.E1, ltepegproof.E2)"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepegproof.entry(ltepegproof.P) = ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n))}")))
 (buildtree_TCC9 0
  (buildtree_TCC13-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))}")))
 (buildtree_TCC10 0
  (buildtree_TCC23-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst?) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree termination
    "ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i)"
    "nil")))
 (buildtree_TCC11 0
  (buildtree_TCC9-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (qstack type-decl nil ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n3)))}")))
 (buildtree_TCC12 0
  (buildtree_TCC29-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (qstack type-decl nil ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree termination
    "ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n3, ltepegproof.i)"
    "nil")))
 (buildtree_TCC13 0
  (buildtree_TCC17-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (qstack type-decl nil ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (defent type-eq-decl nil ltepegproof nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)" "defent")))
 (buildtree_TCC14 0
  (buildtree_TCC31-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (defent type-eq-decl nil ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (qstack type-decl nil ltepegproof nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (good_good? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.two(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n), ltepegproof.E1, ltepegproof.E2)"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepegproof.entry(ltepegproof.P) = ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n))}")))
 (buildtree_TCC15 0
  (buildtree_TCC32-1 nil 3888202986
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (expand "good_tscaffold?")
          (("" (flatten)
            (("" (inst-cp - i n)
              (("" (inst - i n1) (("" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)" "defent")))
 (buildtree_TCC16 0
  (buildtree_TCC15-1 nil 3888202986
   ("" (skeep :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n) (("" (grind-with-ext) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good adt-constructor-decl "[[uint64, uint32] -> (good?)]" ltepeg
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma def-decl "nat" ltepeg nil)
    (good? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent_good_extensionality formula-decl nil ltepeg nil)
    (good_good? const-decl "bool" ltepeg nil)
    (fail adt-constructor-decl "[uint64 -> (fail?)]" ltepeg nil)
    (fail? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent_fail_extensionality formula-decl nil ltepeg nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (/= const-decl "boolean" notequal nil)
    (good_fail? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildtree subtype
    "ltepegproof.zero(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n))"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepegproof.entry(ltepegproof.P) = ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n))}")))
 (no_push_endstate 0
  (no_push_endstate-1 nil 3888892615
   ("" (skeep :preds? t)
    (("" (typepred "st`depth")
      (("" (typepred "st")
        (("" (expand "good_depth?")
          (("" (typepred "st`stack")
            (("" (grind)
              (("" (use "sigma_pos")
                (("1" (ground)
                  (("1" (use "nonempty_card[below(255)]")
                    (("1" (grind) nil nil)
                     ("2"
                      (inst + 255
                       "id[{i_2: below(255) | push?(st`scaf(i)(i_2))}]")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (skeep*)
                  (("2"
                    (inst + 255
                     "id[{i_2: below(255) | push?(st`scaf(i!1)(i_2))}]")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil sigmatopdown nil)
    (empty? const-decl "bool" sigmatopdown nil)
    (state type-eq-decl nil sigmatopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" sigmatopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" sigmatopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" sigmatopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" sigmatopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" sigmatopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" sigmatopdown nil)
    (good_stack? def-decl "bool" sigmatopdown nil)
    (good_push_entry? const-decl "bool" sigmatopdown nil)
    (good_depth? const-decl "bool" sigmatopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" sigmatopdown nil)
    (scaffold type-eq-decl nil sigmatopdown nil)
    (nice_entry? const-decl "bool" sigmatopdown nil)
    (ent type-decl nil sigmatopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil sigmatopdown nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (lang_spec type-eq-decl nil sigmatopdown nil)
    (peg type-decl nil sigmatopdown nil)
    (non_terminal type-eq-decl nil sigmatopdown nil)
    (num_non_terminals const-decl "byte" sigmatopdown nil)
    (byte type-eq-decl nil sigmatopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (index type-eq-decl nil integertypes nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (pushcount const-decl "uint64" sigmatopdown nil)
    (scafcount const-decl "uint64" sigmatopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (nonempty_card formula-decl nil finite_sets nil)
    (below type-eq-decl nil nat_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (sigma_pos formula-decl nil sigmatopdown nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (buildloop_TCC1 0
  (buildloop_TCC1-1 nil 3888290026 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.len"
    "naturalnumbers.upto(ltepegproof.len)")))
 (buildloop_TCC2 0
  (buildloop_TCC2-1 nil 3888290026
   ("" (skeep) (("" (use "scafcount_max") (("" (assert) nil nil)) nil))
    nil)
   ((scafcount_max formula-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (index type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "(number_fields.-)(exp2.exp2(40), ltepeg.scafcount(ltepegproof.len, ltepegproof.A, ltepeg.loop?, ltepegproof.len))"
    "naturalnumber")))
 (buildloop_TCC3 0
  (buildloop_TCC3-1 nil 3888290026 ("" (subtype-tcc) nil nil) nil nil
   (buildloop subtype "ltepegproof.z`1"
    "naturalnumbers.upto(ltepegproof.z`1)")))
 (buildloop_TCC4 0
  (buildloop_TCC4-1 nil 3888290026 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.len"
    "naturalnumbers.upto(ltepegproof.len)")))
 (buildloop_TCC5 0
  (buildloop_TCC5-1 nil 3888290026
   ("" (grind)
    (("1" (typepred "st!1`scaf")
      (("1" (expand "fine_scaffold?")
        (("1" (ground)
          (("1" (inst - i!1 n!1) (("1" (ground) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (typepred "st!1`scaf")
      (("2" (expand "fine_scaffold?")
        (("2" (ground)
          (("2" (inst - i!1 n!1) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("3" (typepred "st!1`scaf")
      (("3" (expand "fine_scaffold?")
        (("3" (ground)
          (("3" (inst - i!1 n!1) (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (typepred "st!1`scaf")
      (("4" (expand "fine_scaffold?")
        (("4" (ground)
          (("4" (inst - i!1 n!1) (("4" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defent? const-decl "bool" ltepegproof nil))
   nil (buildloop subtype "ltepeg.loop" "defent")))
 (buildloop_TCC6 0
  (buildloop_TCC7-1 nil 3888290026
   ("" (grind)
    (("1" (typepred "st!1`scaf")
      (("1" (expand "fine_scaffold?")
        (("1" (ground)
          (("1" (inst - i!1 n!1) (("1" (ground) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (typepred "st!1`scaf")
      (("2" (expand "fine_scaffold?")
        (("2" (ground)
          (("2" (inst - i!1 n!1) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("3" (typepred "st!1`scaf")
      (("3" (expand "fine_scaffold?")
        (("3" (ground)
          (("3" (inst - i!1 n!1) (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (typepred "st!1`scaf")
      (("4" (expand "fine_scaffold?")
        (("4" (ground)
          (("4" (inst - i!1 n!1) (("4" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((good_tscaffold? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (qstack type-decl nil ltepegproof nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nil application-judgement "above(n)" exp2 nil)
    (good_parsetree? def-decl "bool" ltepegproof nil))
   nil
   (buildloop subtype "ltepegproof.zero(ltepeg.loop)"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepeg.loop?(ltepegproof.entry(ltepegproof.P)))}")))
 (buildloop_TCC7 0
  (buildloop_TCC8-1 nil 3888290026 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defent? const-decl "bool" ltepegproof nil))
   nil (buildloop subtype "ltepeg.loop" "defent")))
 (buildloop_TCC8 0
  (buildloop_TCC9-1 nil 3888290026 ("" (subtype-tcc) nil nil)
   ((good_good_entry? const-decl "bool" ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (buildloop subtype "ltepeg.loop"
    "(ltepeg.nice_entry?(ltepegproof.len, ltepegproof.i))")))
 (buildloop_TCC9 0
  (buildloop_TCC12-1 nil 3888290026
   ("" (skeep* :preds? t) (("" (lazy-grind) nil nil)) nil)
   ((good_qstack? def-decl "bool" ltepegproof nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (exp2 def-decl "posnat" exp2 nil)
    (empty? const-decl "bool" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (uint32 type-eq-decl nil integertypes nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S)"
    "{S | booleans.AND(ltepegproof.good_qstack?(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.st`scaf)(ltepegproof.S), FORALL (i_1: naturalnumbers.upto(ltepegproof.len)), (n_1: ltepeg.non_terminal): booleans.IFF(ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop](i_1)(n_1) = ltepeg.loop, ltepegproof.inqstack(n_1, i_1, ltepegproof.S)))}")))
 (buildloop_TCC10 0
  (buildloop_TCC13-1 nil 3888290026
   ("" (grind :if-match nil)
    (("" (typepred "st!1`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (inst - i!1 n!1)
            (("" (grind) (("" (use no_push_endstate) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (qstack type-decl nil ltepegproof nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.loop?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))}")))
 (buildloop_TCC11 0
  (buildloop_TCC14-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (rewrite "scafcount_update")
      (("" (grind :exclude "exp2") nil nil)) nil))
    nil)
   ((scafcount_update formula-decl nil ltepeg nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop termination
    "ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i)"
    "nil")))
 (buildloop_TCC12 0
  (buildloop_TCC10-1 nil 3888290026
   ("" (skeep* :preds? t)
    ((""
      (typepred
       "v(len, G, s, rootpos, rootnt, st, A WITH [(i)(n) := loop], qpush(n, i, S), n1, i)")
      (("1" (grind) nil nil)
       ("2" (rewrite "scafcount_update")
        (("2" (grind :exclude "exp2") nil nil)) nil)
       ("3" (propax) nil nil)
       ("4" (typepred "st`scaf")
        (("4" (expand "fine_scaffold?")
          (("4" (ground)
            (("1" (inst - i n) (("1" (lazy-grind) nil nil)) nil)
             ("2" (lazy-grind) nil nil))
            nil))
          nil))
        nil)
       ("5" (grind) nil nil))
      nil))
    nil)
   ((entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (defent type-eq-decl nil ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (uint32 type-eq-decl nil integertypes nil)
    (qstack type-decl nil ltepegproof nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (count const-decl "upto(len)" arrayCount nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scafcount_update formula-decl nil ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.one(ltepeg.loop, ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i))"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepeg.loop?(ltepegproof.entry(ltepegproof.P)))}")))
 (buildloop_TCC13 0
  (buildloop_TCC11-1 nil 3888290026 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (defent? const-decl "bool" ltepegproof nil))
   nil (buildloop subtype "ltepeg.loop" "defent")))
 (buildloop_TCC14 0
  (buildloop_TCC22-1 nil 3888290026
   ("" (grind)
    (("" (typepred "st!1`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (inst - i!1 n!1)
            (("" (grind) (("" (use no_push_endstate) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (qstack type-decl nil ltepegproof nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))}")))
 (buildloop_TCC15 0
  (buildloop_TCC30-1 nil 3888290026
   ("" (skeep* :preds? t) (("" (lazy-grind) nil nil)) nil)
   ((num_non_terminals const-decl "byte" ltepeg nil)
    (exp2 def-decl "posnat" exp2 nil)
    (empty? const-decl "bool" ltepeg nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepeg.loop"
    "(ltepeg.nice_entry?(ltepegproof.len, ltepegproof.i))")))
 (buildloop_TCC16 0
  (buildloop_TCC21-1 nil 3888290026
   ("" (skeep* :preds? t) (("" (lazy-grind) nil nil)) nil)
   ((good_qstack? def-decl "bool" ltepegproof nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (exp2 def-decl "posnat" exp2 nil)
    (empty? const-decl "bool" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (uint32 type-eq-decl nil integertypes nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S)"
    "{S | booleans.AND(ltepegproof.good_qstack?(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.st`scaf)(ltepegproof.S), FORALL (i_1: naturalnumbers.upto(ltepegproof.len)), (n_1: ltepeg.non_terminal): booleans.IFF(ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop](i_1)(n_1) = ltepeg.loop, ltepegproof.inqstack(n_1, i_1, ltepegproof.S)))}")))
 (buildloop_TCC17 0
  (buildloop_TCC15-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (expand "good_tscaffold?")
          (("" (flatten)
            (("" (inst - i n)
              (("" (typepred "st`scaf(i)(n1)")
                (("" (grind)
                  (("1" (use "no_push_endstate") nil nil)
                   ("2" (use "no_push_endstate") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (no_push_endstate formula-decl nil ltepegproof nil)
    (span adt-accessor-decl "[(good?) -> uint32]" ltepeg nil)
    (good? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "((number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1))))"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.loop?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n2)))}")))
 (buildloop_TCC18 0
  (buildloop_TCC23-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (rewrite "scafcount_update")
      (("" (grind :exclude "exp2") nil nil)) nil))
    nil)
   ((scafcount_update formula-decl nil ltepeg nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop termination
    "ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n2, ((number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))))"
    "nil")))
 (buildloop_TCC19 0
  (buildloop_TCC16-1 nil 3888290026
   ("" (skeep* :preds? t)
    ((""
      (typepred
       "v(len, G, s, rootpos, rootnt, st, A WITH [(i)(n) := loop], qpush(n, i, S), n2, (i + span(st`scaf(i)(n1))))")
      (("1" (grind :if-match nil)
        (("1" (typepred "st`scaf(i)(n1)") (("1" (grind) nil nil)) nil))
        nil)
       ("2" (rewrite "scafcount_update")
        (("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)
       ("3" (hide 4)
        (("3" (typepred "st`scaf(i)(n1)")
          (("3" (typepred "st`scaf")
            (("3" (expand "fine_scaffold?")
              (("3" (flatten)
                (("3" (expand "good_tscaffold?")
                  (("3" (inst - i n)
                    (("3" (grind)
                      (("1" (use "no_push_endstate") nil nil)
                       ("2" (use "no_push_endstate") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (propax) nil nil)
       ("5" (hide 4) (("5" (lazy-grind) nil nil)) nil)
       ("6" (hide 4) (("6" (grind) nil nil)) nil))
      nil))
    nil)
   ((entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (defent type-eq-decl nil ltepegproof nil)
    (defent? const-decl "bool" ltepegproof nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (span adt-accessor-decl "[(good?) -> uint32]" ltepeg nil)
    (good? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (qpush adt-constructor-decl
     "[[non_terminal, uint32, qstack] -> (qpush?)]" ltepegproof nil)
    (qpush? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (uint32 type-eq-decl nil integertypes nil)
    (qstack type-decl nil ltepegproof nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (count const-decl "upto(len)" arrayCount nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scafcount_update formula-decl nil ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (no_push_endstate formula-decl nil ltepegproof nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.two(ltepeg.loop, ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i), ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n2, ((number_fields.+)(ltepegproof.i, ltepeg.span(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1))))))"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepeg.loop?(ltepegproof.entry(ltepegproof.P)))}")))
 (buildloop_TCC20 0
  (buildloop_TCC35-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n)
              (("" (grind)
                (("1" (use no_push_endstate) nil nil)
                 ("2" (use no_push_endstate) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_root? const-decl "bool" ltepeg nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (defent? const-decl "bool" ltepegproof nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil (buildloop subtype "ltepeg.loop" "defent")))
 (buildloop_TCC21 0
  (buildloop_TCC34-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - i n)
              (("" (grind)
                (("1" (use no_push_endstate) nil nil)
                 ("2" (use no_push_endstate) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (no_push_endstate formula-decl nil ltepegproof nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n1)))}")))
 (buildloop_TCC22 0
  (buildloop_TCC17-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (expand "good_tscaffold?")
          (("" (flatten)
            (("" (inst - i n)
              (("" (typepred "st`scaf(i)(n1)")
                (("" (grind)
                  (("1" (use "no_push_endstate") nil nil)
                   ("2" (use "no_push_endstate") nil nil)
                   ("3" (use "no_push_endstate") nil nil)
                   ("4" (use "no_push_endstate") nil nil)
                   ("5" (use "no_push_endstate") nil nil)
                   ("6" (use "no_push_endstate") nil nil)
                   ("7" (use "no_push_endstate") nil nil)
                   ("8" (use "no_push_endstate") nil nil)
                   ("9" (use "no_push_endstate") nil nil)
                   ("10" (use "no_push_endstate") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepeg.loop"
    "(ltepeg.nice_entry?(ltepegproof.len, ltepegproof.i))")))
 (buildloop_TCC23 0
  (buildloop_TCC43-1 nil 3888290026
   ("" (skeep* :preds? t) (("" (lazy-grind) nil nil)) nil)
   ((good_qstack? def-decl "bool" ltepegproof nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (exp2 def-decl "posnat" exp2 nil)
    (empty? const-decl "bool" ltepeg nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (uint32 type-eq-decl nil integertypes nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S)"
    "{S | booleans.AND(ltepegproof.good_qstack?(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.st`scaf)(ltepegproof.S), FORALL (i_1: naturalnumbers.upto(ltepegproof.len)), (n_1: ltepeg.non_terminal): booleans.IFF(ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop](i_1)(n_1) = ltepeg.loop, ltepegproof.inqstack(n_1, i_1, ltepegproof.S)))}")))
 (buildloop_TCC24 0
  (buildloop_TCC31-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (expand "fine_scaffold?")
        (("" (expand "good_tscaffold?")
          (("" (flatten)
            (("" (inst - i n)
              (("" (typepred "st`scaf(i)(n1)")
                (("" (grind)
                  (("1" (use "no_push_endstate") nil nil)
                   ("2" (use "no_push_endstate") nil nil)
                   ("3" (use "no_push_endstate") nil nil)
                   ("4" (use "no_push_endstate") nil nil)
                   ("5" (use "no_push_endstate") nil nil)
                   ("6" (use "no_push_endstate") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (no_push_endstate formula-decl nil ltepegproof nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.loop?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n3)))}")))
 (buildloop_TCC25 0
  (buildloop_TCC32-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (rewrite "scafcount_update")
      (("" (grind :exclude "exp2") nil nil)) nil))
    nil)
   ((scafcount_update formula-decl nil ltepeg nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop termination
    "ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n3, ltepegproof.i)"
    "nil")))
 (buildloop_TCC26 0
  (buildloop_TCC18-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (grind :if-match nil)
      (("" (typepred "st`scaf(i)(n1)")
        (("" (grind)
          (("1" (use "no_push_endstate") nil nil)
           ("2" (typepred "st`scaf")
            (("2" (expand "fine_scaffold?")
              (("2" (ground)
                (("2" (inst - i n) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (empty? const-decl "bool" ltepeg nil)
    (exp2 def-decl "posnat" exp2 nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (no_push_endstate formula-decl nil ltepegproof nil)
    (loop_or_push? const-decl "bool" ltepeg nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (index type-eq-decl nil integertypes nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop subtype
    "ltepegproof.two(ltepeg.loop, ltepegproof.buildtree(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n1, ltepegproof.i), ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A WITH [(ltepegproof.i)(ltepegproof.n) := ltepeg.loop], ltepegproof.qpush(ltepegproof.n, ltepegproof.i, ltepegproof.S), ltepegproof.n3, ltepegproof.i))"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.S, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepeg.loop?(ltepegproof.entry(ltepegproof.P)))}")))
 (buildloop_TCC27 0
  (buildloop_TCC65-1 nil 3888290026
   ("" (skeep* :preds? t)
    (("" (typepred "st`scaf")
      (("" (grind :if-match nil)
        (("1" (inst - i n) (("1" (grind) nil nil)) nil)
         ("2" (inst - i n) (("2" (grind) nil nil)) nil)
         ("3" (inst - i n) (("3" (grind) nil nil)) nil)
         ("4" (inst - i n) (("4" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" ltepeg nil)
    (good_entry? const-decl "bool" ltepeg nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" ltepeg nil)
    (gfcount const-decl "uint64" ltepeg nil)
    (good_tscaffold? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildloop cases "ltepegproof.G(ltepegproof.n)" "prepeg: DATATYPE
 BEGIN
  epsilon: epsilon?
  failure: failure?
  any(p: [byte -> bool]): any?
  terminal(a: byte): terminal?
  lte(fst: non_terminal, lthen: non_terminal, lelse: non_terminal): lte?
 END prepeg")))
 (buildproof_TCC1 0
  (buildproof_TCC1-1 nil 3893983722 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (defent? const-decl "bool" ltepegproof nil)
    (plus_u32_u32 application-judgement "uint64" integertypes nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildproof subtype "ltepegproof.A"
    "ltepeg.scaffold(ltepegproof.len)")))
 (buildproof_TCC2 0
  (buildproof_TCC2-1 nil 3893983722 ("" (grind) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (good_qstack? def-decl "bool" ltepegproof nil))
   nil
   (buildproof subtype "ltepegproof.qempty"
    "{S | booleans.AND(ltepegproof.good_qstack?(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.st`scaf)(ltepegproof.S), FORALL (i: naturalnumbers.upto(ltepegproof.len)), n: (booleans.NOT)(ltepegproof.inqstack(ltepegproof.n, i, ltepegproof.S)))}")))
 (buildproof_TCC3 0
  (buildproof_TCC3-1 nil 3893983722 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (defent? const-decl "bool" ltepegproof nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildproof subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.loop?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)))}")))
 (buildproof_TCC4 0
  (buildproof_TCC4-1 nil 3893983722
   ("" (skeep*)
    ((""
      (typepred "buildloop(len, G, s, rootpos, rootnt)
                               (st, A, qempty, n, i)")
      (("1" (ground) nil nil) ("2" (propax) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil))
      nil))
    nil)
   ((pending? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (buildloop def-decl
     "{P | good_parsetree?(len, G, s)(S, n, i, P) AND loop?(entry(P))}"
     ltepegproof nil)
    (entry shared-adt-accessor-decl "[parsetree -> defent]" ltepegproof
     nil)
    (defent type-eq-decl nil ltepegproof nil)
    (inqstack def-decl "bool" ltepegproof nil)
    (loop adt-constructor-decl "(loop?)" ltepeg nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (good_qstack? def-decl "bool" ltepegproof nil)
    (endstate type-eq-decl nil ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (defent? const-decl "bool" ltepegproof nil)
    (ent type-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (qempty adt-constructor-decl "(qempty?)" ltepegproof nil)
    (qempty? adt-recognizer-decl "[qstack -> boolean]" ltepegproof nil)
    (good_parsetree? def-decl "bool" ltepegproof nil)
    (parsetree type-decl nil ltepegproof nil)
    (uint32 type-eq-decl nil integertypes nil)
    (qstack type-decl nil ltepegproof nil)
    (strings type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (byte type-eq-decl nil ltepeg nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (index type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" ltepeg nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildproof subtype
    "ltepegproof.buildloop(ltepegproof.len, ltepegproof.G, ltepegproof.s, ltepegproof.rootpos, ltepegproof.rootnt, ltepegproof.st, ltepegproof.A, ltepegproof.qempty, ltepegproof.n, ltepegproof.i)"
    "{P | booleans.AND(ltepegproof.good_parsetree?(ltepegproof.len, ltepegproof.G, ltepegproof.s)(ltepegproof.qempty, ltepegproof.n, ltepegproof.i, ltepegproof.P), ltepegproof.entry(ltepegproof.P) = ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n))}")))
 (buildproof_TCC5 0
  (buildproof_TCC5-1 nil 3893983722 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (index type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (byte type-eq-decl nil ltepeg nil)
    (num_non_terminals const-decl "byte" ltepeg nil)
    (non_terminal type-eq-decl nil ltepeg nil)
    (ent type-decl nil ltepeg nil)
    (push? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (empty? const-decl "bool" ltepeg nil)
    (prepeg type-decl nil ltepeg nil)
    (lang_spec type-eq-decl nil ltepeg nil)
    (below type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil ltepeg nil)
    (nice_entry? const-decl "bool" ltepeg nil)
    (scaffold type-eq-decl nil ltepeg nil)
    (fine_scaffold? const-decl "bool" ltepeg nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" ltepeg nil)
    (good_push_entry? const-decl "bool" ltepeg nil)
    (good_stack? def-decl "bool" ltepeg nil)
    (fine_stack? def-decl "bool" ltepeg nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" ltepeg nil)
    (loop_ready? const-decl "bool" ltepeg nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" ltepeg nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" ltepeg nil)
    (state type-eq-decl nil ltepeg nil)
    (endstate type-eq-decl nil ltepeg nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (defent? const-decl "bool" ltepegproof nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_or_fail? const-decl "bool" ltepeg nil)
    (nil application-judgement "above(n)" exp2 nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (buildproof subtype "ltepegproof.i"
    "{i | booleans.AND(reals.<=(ltepegproof.i, ltepegproof.len), ltepeg.good_or_fail?(ltepegproof.st`scaf(ltepegproof.i)(ltepegproof.n)))}"))))

