author:  N. Shankar 
title: \textbf{Robust Proof and Code Generation}
date: Oct 10, 2023
preamble: \usepackage{tabularx}\usepackage{url}
\setbeamercolor{title}{fg=white!80!blue}
\setbeamercovered{transparent}
%\logo{\includegraphics[height=0.5cm]{images/sri_blue_logo.jpg}}
 \input{smacros}
\usepackage{tikz}
\usetikzlibrary{calc,positioning,fit,shapes}
\usetikzlibrary{tikzmark}
islide: Overview
The number and complexity of data and file formats is growing by the day.

Bad or missing input validation of the input in these formats is a major source of security vulnerabilities.

The Parsley data definition language is a way of specifying such language formats based on
\begin{enumerate}
\item Parsing Expression Grammars (PEGs) as the basic grammar definition
\item Attribute grammars for capturing data dependencies using inherited and synthesized attributes over PEG grammars
  \item A functional language for defining computations and constraints. 
\end{enumerate}

The talk focuses on the PEG aspect of Parsley with a verification and proof of, and code extraction from,
a parsing abstract machine for PEGs.


islide:  Managing the Proof Lifecycle
The 1992 CADE paper introducing PVS captures the motivation for many of the design choices in PVS
for supporting the scalable construction of robust proofs: 
{\small\smaller\smaller
  \begin{quote}
  \emph{Our experience with mechanical verification of complex
    designs and algorithms has led us to conclude that, just as with software, there is a lifecycle
    to a mechanically-checked proof. In the initial exploratory phase of proof development, we are
    mainly interested in debugging the specification and putative theorems, and in testing and
    revising the key, high-level ideas in the proof. An important requirement in this phase is early
    and useful feedback when a purported theorem is, in fact, false. Once the basic intuitions have
    been acquired and the formalization is stable, the proof checking enters a development phase
    where we take care of the details and construct the proof in larger leaps. Efficiency of proof
    development is a key requirement here. In the third, presentation phase,the proof is honed and
    polished for presentation in order to be scrutinized by the social process.  Readability and
    intellectual perspicuity of the output is the goal here. The final phase is generalization where
    we carefully analyze the finished proof, weaken and generalize the assumptions, extract the key
    insights and proof techniques,and make it easier to carry out subsequent verifications of a
    similar nature.  Maintenance is a special application of generalization, where we adapt a
    verification to slightly changed assumptions or requirements.  Robustness of the proof procedure
    is a useful attribute here.  }
  \end{quote}
}


islide: The PVS Language in Brief
%\pause
{\small\smaller A PVS specification is a collection of libraries.
\begin{itemize}
\item Each library is a collection of files.
  \item Each file is a sequence of theories.
    \item Each theory is a sequence of declarations/definitions of types, constants, and formulas (Boolean expressions).
    \end{itemize}
}
%\pause    

{\small\smaller Types include
\begin{enumerate}
\item Booleans, number types
\item Predicate subtypes: $\{x : T | p(x)\}  $ for type $T$ and predicate $p$. 
\item Dependent function $[x: D \rightarrow R(x)]$, tuple $[x : T_1, T_2(x)]$, and record $[\# a: T_1, b: T_2(x) \#]$ types.
\item Algebraic and coalgebraic datatypes: lists, trees, ordinals. 
\end{enumerate}
}
%\pause

{\small\smaller Expressions in PVS are
\begin{enumerate}
\item Booleans, numbers
\item Application : $f(a_1, \ldots, a_n)$
\item Abstraction : $\lambda (x_1: T_1, \ldots, x_n: T_n): a$
\item Tuples: $(a_1, \ldots, a_n)$, $a`3$
\item Records: $({\small \#} l_1:= a_1, \ldots, l_n := a_n {\small \#})$, $a`l_i$
\item Conditionals: $\mbox{IF } {a_1} \mbox{ THEN } {a_2} \mbox{ ELSE } {a_3} \mbox{ ENDIF}$
\item Updates: $a~\mathtt{WITH}~[(3)`1`age := 37]$.    
\end{enumerate}}

islide: Code Generation from a Specification Language: PVS2CL
Quantification and equality over higher types are not executable, but many definitions are. 

Mapping PVS to Common Lisp is relatively direct: each construct is mapped to its Lisp counterpart
and types are transformed in to compiler declarations. 

Array, record, tuple updates are a bit challenging: need to
minimize copying by performing destructive updates.  

PVS2CL uses a static analysis to identify whether a reference is live in the context of
its update.\footnote{Shankar, N.: Static analysis for safe destructive updates in a functional language, LOPSTR 2001.}

%\pause
\rdmph{Code generation is different from implementation --- can't create a bespoke runtime.}

\rdmph{A (principled) specification logic like PVS is not a (pragmatic) programming language. }

\bluemph{Executable specifications are very useful for animation, testing, validation, proof, and system building.}

islide: Functional vs. Imperative
Functional and imperative languages are quite different, both syntactically and semantically. 

%\pause
With functional languages 
\begin{itemize}
\item Referentially transparency is a key property
\item Both manual and mechanical verification are more civilized
\item Evaluation is pure (updates are nondestructive)
\item  Memory management is implicit.
\end{itemize}

%\pause
With imperative languages
\begin{itemize}
\item Scoping is tricky:  No counterpart of let-expressions in many imperative languages
\item Evaluation is triggered by control flow not value flow
\item Semantically closer to machine execution
\item Integrated with extensive libraries and application software
\item Memory management may be explicit, e.g., through \texttt{free} and \texttt{malloc}. 
\end{itemize}

islide: The PVS2C Code Generator
PVS2C generates safe, efficient, standalone C code for a full functional fragment of PVS.

Each PVS theory \texttt{foo.pvs} generates a \texttt{foo.h} and \texttt{foo.c}.\footnote{\smaller\smaller F\'erey, G., Sh\_, N.: Code Generation using a formal model of reference counting, NFM 2016.  See also Wolfram Schulte, 
 Deriving reference count garbage collectors,  {\em 6th International Symposium on Programming Language
  Implementation and Logic Programming}, 1994.}
}

The translation is factored through an intermediate language that represents PVS expressions in A-normal form and
performs a light static analysis to identify the \emph{release points} for references.
\begin{center}
  \includegraphics[width=.9\linewidth]{/Users/e21660/shankar/projects/PVSCodeGen/Figures/pvs2c.png}
\end{center}

islide: PVS2C: Putting Theory to Use
The theoretical outline above deals with an idealized first-order language with
(unbounded) integers and arrays.  

%\pause
The full PVS2C implementation covers
\begin{enumerate}
\item Multi-precision rational numbers and integers, and floats
\item Fixed-size arithmetic: \texttt{uint8}, \texttt{uint16}, \texttt{uint32}, \texttt{uint64}, \texttt{int8}, \texttt{int16}, \texttt{int32}, \texttt{int64}, with safe casting  
\item Dependent (dynamically sized) and infinite arrays 
\item Dependent records and tuples
\item Higher-order functions and closures (with updates) 
\item Characters (ASCII and Unicode)  and strings  
\item Algebraic datatypes
\item Parametric theories with type parameters (unboxed polymorphism)
\item Memory-mapped File I/O
\item Semantic attachments
\item JSON representation for data
\end{enumerate}

%\pause
PVS2C captures a functional subset of PVS that is usable as a safe programming language
- a well-typed program cannot fail (modulo resource limitations).


slide: Experiments in Code Generation: HMAC from Wikipedia
{\small\smaller\smaller \begin{smallersession}
function hmac is
    input:
        key:        Bytes    // Array of bytes
        message:    Bytes    // Array of bytes to be hashed
        hash:       Function // The hash function to use (e.g. SHA-1)
        blockSize:  Integer  // The block size of the hash function 
                                           //(e.g. 64 bytes for SHA-1)
        outputSize: Integer  // The output size of the hash function 
                                           //(e.g. 20 bytes for SHA-1)
 
    // Keys longer than blockSize are shortened by hashing them
    if (length(key) > blockSize) then
        key <- hash(key) // key is outputSize bytes long

    // Keys shorter than blockSize are padded to blockSize by padding 
    //with zeros on the right
    if (length(key) < blockSize) then
        key <- Pad(key, blockSize) // Pad key with zeros to make it
                                   // blockSize  bytes long
    o_key_pad <- key xor [0x5c * blockSize]   // Outer padded key
    i_key_pad <- key xor [0x36 * blockSize]   // Inner padded key
    return hash(o_key_pad \(\|\) hash(i_key_pad \(\|\) message))
  \end{smallersession}}

  slide: HMAC in PVS
  \begin{smallersession}
{\smaller    
hmac(blockSize: uint8,
     key : bytestring,
     (message : bytestring |
        message`length + blockSize < bytestring_bound),
     outputSize: upto(blockSize),
     hash: [bytestring->lbytes(outputSize)]): lbytes(outputSize)
= LET newkey = IF length(key) > blockSize THEN hash(key) ELSE key ENDIF,
      newerkey: lbytes(blockSize)
       = IF length(newkey) < blockSize
          THEN padright(blockSize)(newkey)
          ELSE newkey
         ENDIF, 
      oKeyPad = lbytesXOR(blockSize)(newerkey, nbytes(0x5c, blockSize)),
      iKeyPad = lbytesXOR(blockSize)(newerkey, nbytes(0x36, blockSize))
   IN hash(oKeyPad ++ hash(iKeyPad ++ message))

hmac256((blockSize: uint8 | 32 <= blockSize),
        key : bytestring,
        (message : bytestring | 
             message`length + blockSize < bytestring_bound))
      : lbytes(32)
= hmac(blockSize, key, message, 32, sha256message)    
}    \end{smallersession}

    slide: HMAC Generated by PVS2C
{\tiny\smaller    \begin{smallersession}
    bytestrings__bytestring_t
    HMAC__hmac256(uint8_t ivar_2, bytestrings__bytestring_t ivar_3,
                  bytestrings__bytestring_t ivar_4)\{
        bytestrings__bytestring_t  result;
        uint8_t ivar_18;
        ivar_18 = (uint8_t)32;
        HMAC_funtype_0_t ivar_19;
        HMAC_closure_3_t cl1230;
        cl1230 = new_HMAC_closure_3();
        ivar_19 = (HMAC_funtype_0_t)cl1230;
        bytestrings__bytestring_t ivar_14;
        ivar_14 = (bytestrings__bytestring_t)
        HMAC__hmac((uint8_t)ivar_2, (bytestrings__bytestring_t)ivar_3,
                   (bytestrings__bytestring_t)ivar_4, (uint8_t)ivar_18,
                   (HMAC_funtype_0_t)ivar_19);
        //copying to bytestrings__bytestring
        //from bytestrings__bytestring;
        result = (bytestrings__bytestring_t)ivar_14;
        if (result != NULL) result->count++;
        release_bytestrings__bytestring(ivar_14);
        return result;
\}
    \end{smallersession}}

  slide: (Chomsky-normal form) PEGs in PVS
  \begin{smallersession}
len, max: VAR index %the length of the input
byte: TYPE = below(256)
strings(len): TYPE = ARRAY[below(len) -> byte]
num_non_terminals: byte = 255
non_terminal: TYPE = below(num_non_terminals)

peg  : DATATYPE
  BEGIN
   epsilon : epsilon?
   failure : failure?
   any(p : [byte -> bool]) : any?
   terminal(a: byte) : terminal?
   concat(e1, e2: non_terminal) : concat?
   choice(e1, e2: non_terminal) : or?
   check(e: non_terminal) : and?
   neg(e: non_terminal) : not?
  END peg
\end{smallersession}

slide: The Scaffold
The scaffold is a two-dimensional array mapping each position/nonterminal to an entry.
\begin{smallersession}
scaffold(len) : TYPE = ARRAY[pos: upto(len) -> ARRAY[non_terminal -> (nice_entry?(len, pos))]]  
\end{smallersession}
$$
\begin{array}{|r||c|c|c|c|c|}\hline
  & 0 & \ldots & i & \ldots & L \\\hline\hline
  n0 & a_{00}& \ldots & a_{i0}\tikzmark{a} & \ldots & a_{L0}\\\hline
  \vdots & \vdots & \vdots & \vdots & \vdots & \vdots\\\hline
  nj & \ldots & \ldots & a_{ij}\tikzmark{b} & \ldots & a_{Lj}\\\hline
  \vdots & \vdots & \vdots & \vdots & \tikzmark{c}\vdots & \vdots\\\hline  
  nN & a_{0N}& \ldots & a_{iN} & \ldots & a_{LN}\\\hline
\end{array}
$$
\begin{tikzpicture}[overlay, remember picture, yshift=.25\baselineskip, shorten >=.5pt, shorten <=.5pt]
    \draw [->] ({pic cs:b}) [bend right] to ({pic cs:a});
    \draw [->] ([yshift=.75pt]{pic cs:b}) -- ({pic cs:c});
  \end{tikzpicture}

  slide: Step Function
  \begin{smallersession}
step(len, G, (s: strings(len)), (start: upto(len)),
     (rootnt: non_terminal))
    (St : state(len, G, s, start, rootnt))
    : state(len, G, s, start, rootnt)
 = (LET scaf = St`scaf,
	stack = St`stack,
	depth = St`depth,
	lflag = St`lflag
     IN
    IF empty?(stack)
    THEN St
    ELSE LET pos = pos(stack),
             cur = nt(stack),
	     rest = scaf(pos)(cur)
	  IN CASES G(cur) OF
          epsilon: St WITH [`scaf(pos)(cur) := good(0, 0),
                            `stack := rest,
                            `depth := depth - 1],
    \vdots
  \end{smallersession}

  slide:  Outer Parsing Loop
  \begin{smallersession}
    parse(len, G, (s: strings(len)), (start: upto(len)),
           (root: non_terminal), St : state(len, G, s, start, root))
    : RECURSIVE endstate(len, G, s, start, root)
  = (IF St`depth = 0
      THEN St
      ELSE parse(len, G, s, start, root,
                 step(len, G, s, start, root)(St))
      ENDIF)
      MEASURE size(len, G, s, start, root)(St) BY <
    \end{smallersession}

slide: Proof-of-Parse Verification    
    Defined a proof-of-parse format for success, failure, loop outcomes and extracted valid proofs from parser output.
\begin{smallersession}
  buildproof(len, G, (s: strings(len)),
              (rootpos: upto(len)), (rootnt: non_terminal))
            (st: endstate(len, G, s, rootpos, rootnt),
              n, (i | i <= len)): 
     \{P | good_parsetree?(len, G, s)(qempty, n, i, P)
           AND entry(P) = st`scaf(i)(n)\}
  = (IF loop?(st`scaf(i)(n))
     THEN  (LET pendfun = (LAMBDA (n: non_terminal): pending),
                      A = (LAMBDA (i: upto(len)): pendfun)
             IN buildloop(len, G, s, rootpos, rootnt)
                         (st, A, qempty, n, i))
     ELSE buildtree(len, G, s, rootpos, rootnt)(st, qempty, n, i)
     ENDIF)
      
    \end{smallersession}

    slide: Introducing \texttt{let-then-else}
    Even with memoization (packrat parsing), the PEG grammar can be slow because it is not backtracking efficiently from failure.

    
    A variant \texttt{let x = A then B else C} can be used more efficiently and replaces several PEG constructors.
    \begin{smallersession}
prepeg: DATATYPE
BEGIN
   epsilon : epsilon?
   failure : failure?
   any(p : [byte -> bool]) : any?
   terminal(a: byte) : terminal?
   lte(fst: non_terminal, lthen : non_terminal, lelse: non_terminal)
     : lte? 
END prepeg
      
    \end{smallersession}

    The original proofs were hard: took around six week with over a 150 nontrivial proof obligations.  

    Proofs replayed robustly even though the change was significant.
    
    But the speed-up was only around 30\%

    slide: Extending the Base Case to DFAs
    One source of slowness is that the base case handles only one character at a time.

    The proposed remedy was to make the base case cover any DFA.
    (This is tricky DFA and PEG semantics are not compatible.)

    \begin{smallersession}
prepeg: DATATYPE
BEGIN
   epsilon : epsilon?
   failure : failure?
   any(dfa : dfa) : any?
   terminal(a: byte) : terminal?
   lte(fst: non_terminal, lthen : non_terminal, lelse: non_terminal)
     : lte? 
END prepeg
\end{smallersession}

With this, the speedup was substantial.


  islide: Conclusions
  Modeling dominates the software development activity for critical systems.

  Refinement and code generation bridge the semantic gap between models and code.

  Robust proofs make it easier to evolve better models and implementations. 


  The efficiency of code generated from verified high-level models can be competitive with \emph{hand-written code}.
  
Code generation can be used to create standalone components or define entire systems.

\bluemph{The key value proposition is the use of one unified system and language for
  specification, modeling, programming, and proof.  }
