pegtopdownHashmaptest 	: THEORY

  BEGIN
   IMPORTING pegtopdownHashmap

   digit(c : char): bool = (code(c) >= 48 AND code(c) <= 57)
   any(c: char): bool = TRUE
   

   pyaml(n: non_terminal): peg =
   COND 
    n = 0 -> choice(1, 3),  %data -> numeral / adata
    n = 1 ->  concat(2, 1),  %numeral -> any(48-57) o numeral
    n = 2 -> any(digit),
    n = 3 -> choice(4, 35),  %adata -> dict / array
    n = 4 -> concat(5, 11),  %dict -> obrace o dictail
    n = 5 -> concat(6, 7),  %obrace -> { o wspace
    n = 6 -> terminal("{"), %{
    n = 7 -> choice(8, 10), %wspace ->  wspace$ / epsilon
    n = 8 -> concat(9, 7),  %wspace$ -> terminal(32) o wspace
    n = 9 -> terminal(" "),  %space
    n = 10 -> epsilon,
    n = 11 -> choice(12, 14), %dictail -> cbrace / dictail$
    n = 12 -> concat(13, 7), %cbrace -> terminal(125) o wspace
    n = 13 -> terminal("}"),
    n = 14 -> concat(15, 31), % dictail$ -> dictentry o dictailc
    n = 15 -> concat(16, 28), %dictentry -> lhs o seprhs
    n = 16 -> choice(1, 17),  %lhs -> numeral / token
    n = 17 -> concat(18, 7), %token -> token$ o wspace
    n = 18 -> concat(19, 25), %token$ -> terminal(39) o tokentail
    n = 19 -> terminal("'"),
    n = 20 -> choice(21, 25), %tokentail-> esctail / qtail
    n = 21 -> concat(22, 20), %esctail -> esquote o tokentail
    n = 22 -> concat(23, 19), %esquote -> terminal(92) o terminal(39)
    n = 23 -> terminal("\\"),
    n = 24 -> concat(19, 7), %quote -> terminal(39) o wspace
    n = 25 -> choice(24, 26), %qtail -> quote / tktail
    n = 26 -> concat(27, 20), %tktail -> any o tokentail
    n = 27 -> pegtopdownHashmap.any(any),
    n = 28 -> concat(29, 0), %seprhs -> separator o data
    n = 29 -> concat(30, 7), %separator -> terminal(58) o wspace
    n = 30 -> terminal(":"),
    n = 31 -> choice(32, 12),  %dictailc -> cdictailc / cbrace
    n = 32 -> concat(33, 14),   %cdictailc -> comma o dictail$
    n = 33 -> concat(34, 7),  %comma -> terminal(44) o wspace 
    n = 34 -> terminal(","),
    n = 35 -> concat(36, 38), %array -> obrack o aentries
    n = 36 -> concat(37, 7), %obrack -> terminal(91) o wspace 
    n = 37 -> terminal("["),
    n = 38 -> choice(39, 43), %aentries -> aentries* o cbrack
    n = 39 -> choice(40, 10), %aentries* -> aentries$ / epsilon
    n = 40 -> concat(0, 41), %aentries$ -> data o aentriestail
    n = 41 -> choice(42, 10), %aentriestail -> centries / epsilon
    n = 42 -> concat(33, 40), %centries -> comma o aentries$
    n = 43 -> concat(44, 7),  %cbrack -> terminal(93) o wspace
    n = 44 -> terminal("]"),
    ELSE -> epsilon
    ENDCOND

    len, l1, l2 : VAR uint32
    
%    empty(len)(i:below(len)): byte = 32

    % cat(l1, (l2 : below(exp2(8) - l1)))(s1: strings(l1), s2: strings(l2)): strings(l1 + l2) = 
    %  LAMBDA (i:below(l1 + l2)): IF i < l1 THEN s1(i) ELSE s2(i - l1) ENDIF

    tok0: strings(7) = "'token'"

    % tok0(i : below(7)): byte =
    %  COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 39 ENDCOND

    tok1: strings(9) = "'token\\''"
    
    % tok1(i : below(9)): byte =
    %  COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 92, i = 7 -> 39, i = 8 -> 39 ENDCOND

    emptydict : strings(9) = "{      } "

    % emptydict(i: below(9)): byte = 
    %      COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32, i = 3 -> 32, i = 4 -> 32, i = 5 -> 32, i = 6 -> 32, i = 7 -> 125, i = 8 -> 32 ENDCOND

    obrace: strings(3) = "{  "
    cbrace: strings(3) = "}  "
    colon: strings(3) = ":  "

    % obrace(i: below(3)): byte = COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32 ENDCOND
    % cbrace(i: below(3)): byte = COND i = 0 -> 125, i = 1 -> 32, i = 2 -> 32 ENDCOND
    % colon(i: below(3)): byte = COND i = 0 -> 58, i = 1 -> 32, i = 2 -> 32 ENDCOND
    emptydict2: strings(6) =
      concat(obrace, cbrace)

    csl(i, j: uint8)(s: strings(j)): RECURSIVE strings(max(0, (i*(j + 2)) - 2))
    = (IF i = 0 THEN ""
       ELSIF i = 1 THEN s
       ELSE concat(s, concat(", ", csl(i-1, j)(s)))
       ENDIF)
       MEASURE i

    array_of_emptydicts(i: uint16): strings(11*i) =
        concat("[", concat(csl(i, 9)(emptydict), "]"))

    dict1: strings(22) =
      concat(obrace, concat(tok0, concat(colon, concat(emptydict2, cbrace))))

    test0: ent = doparse(2, pyaml, "  ", 7)
    test0eval: LEMMA good?(test0)
     
    test1: ent = doparse(7, pyaml, tok0, 17)
    test11: ent = doparse(9, pyaml, tok1, 17)
    test2: ent = doparse(22, pyaml, dict1, 0)

    test_emptydicts(i: nat): ent = doparse(9*i, pyaml, array_of_emptydicts(i), 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    pparens(n: non_terminal): peg =
   COND 
    n = 0 -> choice(1, 6),  
    n = 1 ->  concat(2, 3),  
    n = 2 -> terminal("("),
    n = 3 -> concat(0, 4),  
    n = 4 -> concat(5, 0),  
    n = 5 -> terminal(")"),
    n = 6 -> epsilon,
    ELSE -> epsilon
   ENDCOND

   testparens0: ent = doparse(8, pparens, "(()())()", 0)
   testparens1: ent = doparse(9, pparens, "((()())()", 0)
   testparens2: ent = doparse(9, pparens, "(()()))()", 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    ppow(n: non_terminal): peg =
   COND 
    n = 0 -> concat(1, 10), 
    n = 1 ->  choice(2, 5),  
    n = 2 -> concat(3, 4), 
    n = 3 -> any(LAMBDA (c: char): true),
    n = 4 -> concat(1, 3), 
    n = 5 -> choice(6, 9), 
    n = 6 -> concat(3, 7),
    n = 7 -> concat(8, 3),
    n = 8 -> check(1),
    n = 9 -> epsilon,
    n = 10 -> neg(3),
    ELSE -> epsilon
   ENDCOND

   testpow0: ent = doparse(6, ppow, "parsed", 0)
   testpow1: ent = doparse(8, ppow, "reparsed", 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    ploop(n: non_terminal): peg =
   COND 
    n = 0 -> concat(1, 10), 
    n = 1 ->  concat(2, 4),  
    n = 2 -> neg(3),
    n = 3 -> terminal("c"),
    n = 4 -> concat(5, 8),
    n = 5 -> choice(6, 7), 
    n = 6 -> terminal("a"),
    n = 7 -> epsilon,
    n = 8 -> choice(9, 7),
    n = 9 -> terminal("b"),
    n = 10 -> choice(11, 0),
    n = 11 -> terminal("#"),
    ELSE -> epsilon
   ENDCOND

   testloop0: ent = doparse(6, ploop, "abbda#e", 0)
   testloop1: ent = doparse(8, ploop, "abbca#e", 0)




    
  END pegtopdownHashmaptest
