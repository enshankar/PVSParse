
%% PVS Version 7.1.37 - International Allegro CL Enterprise Edition 10.1 [64-bit Mac OS X (Intel)] (Jun 6, 2021 14:53)
%% 10.1 [64-bit Mac OS X (Intel)] (Jun 6, 2021 14:53)
$$$PVSHOME/.pvs.lisp
(in-package :pvs)


$$$arrayCount.pvs
arrayCount   [T: TYPE ]
		: THEORY

  BEGIN

  len: VAR nat

  P: VAR [T -> bool]

   arr(len): TYPE = [below(len) -> T]

   count(len)(P)(A : arr(len)): upto(len) =
     card({i : below(len) | P(A(i))})

   u, v: VAR T

   count_update0: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES  count(len)(P)(A WITH [(i) := u]) = count(len)(P)(A) + 1)

   count_update: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES count(len)(P)(A) < count(len)(P)(A WITH [(i) := u]))

   count_update00: LEMMA
      (FORALL (i: below(len)), (A : arr(len)):
          count(len)(P)(A WITH [(i) := u]) =
	   IF P(A(i)) THEN IF P(u) THEN count(len)(P)(A) ELSE count(len)(P)(A) - 1 ENDIF
	    ELSIF P(u) THEN count(len)(P)(A) + 1 ELSE count(len)(P)(A) ENDIF)


   count_update1: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       NOT P(A(i)) AND P(u)
         IMPLIES count(len)(P)(A) < count(len)(P)(A WITH [(i) |-> u]))

   count_update2: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       P(A(i)) AND NOT P(u)
         IMPLIES count(len)(P)(A WITH [(i) := u]) < count(len)(P)(A))

   count_update3: LEMMA
     (FORALL (i: below(len)), (A : arr(len)):
       P(A(i)) AND NOT P(u)
         IMPLIES count(len)(P)(A WITH [(i) |-> u]) < count(len)(P)(A))


  END arrayCount

$$$arrayCount.prf
(arrayCount
 (count_TCC1 0
  (count_TCC1-1 nil 3798315575
   ("" (skeep)
    (("" (expand "is_finite")
      (("" (inst + "len" "id")
        (("" (typepred "id")
          (("" (expand "bijective?") (("" (ground) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((is_finite const-decl "bool" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (below type-eq-decl nil nat_types nil)
    (arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (count subtype
          "{i: naturalnumbers.below(arrayCount.len) | arrayCount.P(arrayCount.A(i))}"
     "finite_set[below(len)]")))
 (count_TCC2 0
  (count_TCC2-1 nil 3798315575
   ("" (skeep)
    (("" (typepred "card[below(len)]({i: below(len) | P(A(i))})")
      (("1" (replace -1 :hide? t)
        (("1" (rewrite "Card_injection")
          (("1" (inst + "id")
            (("1" (typepred "id")
              (("1" (expand "bijective?") (("1" (ground) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "count_TCC1") nil nil))
      nil))
    nil)
   ((arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Card_injection formula-decl nil finite_sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (below type-eq-decl nil nat_types nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (count_TCC1 subtype-tcc nil arrayCount nil))
   nil
   (count subtype
          "finite_sets[naturalnumbers.below(arrayCount.len)].card({i: naturalnumbers.below(arrayCount.len) | arrayCount.P(arrayCount.A(i))})"
     "naturalnumbers.upto(arrayCount.len)")))
 (count_update0 0
  (count_update0-1 nil 3804561128
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_add formula-decl nil finite_sets nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (below type-eq-decl nil nat_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (finite_subset formula-decl nil finite_sets nil)
    (TRUE const-decl "bool" booleans nil)
    (count const-decl "upto(len)" arrayCount nil))
   shostak))
 (count_update 0
  (count_update-1 nil 3798315577
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card_add formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   shostak))
 (count_update00 0
  (count_update00-1 nil 3806985200
   ("" (skeep)
    (("" (lift-if)
      (("" (ground)
        (("1" (expand count)
          (("1"
            (case-replace
             "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = {i: below(len) | P(A(i))}")
            (("1" (hide 2) (("1" (grind-with-ext) nil nil)) nil)) nil))
          nil)
         ("2" (expand count)
          (("2"
            (case-replace
             "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = remove(i, {i: below(len) | P(A(i))})")
            (("1" (rewrite card_remove)
              (("1" (use count_TCC1) nil nil)) nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil)
         ("3" (expand count)
          (("3"
            (case-replace
             "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
            (("1" (rewrite card_add) (("1" (use count_TCC1) nil nil))
              nil)
             ("2" (grind-with-ext) nil nil))
            nil))
          nil)
         ("4" (expand count)
          (("4"
            (case-replace
             "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = {i: below(len) | P(A(i))}")
            (("4" (grind-with-ext) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((card_add formula-decl nil finite_sets nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (card_remove formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (count_TCC1 subtype-tcc nil arrayCount nil)
    (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (count const-decl "upto(len)" arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (T formal-type-decl nil arrayCount nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (count_update1 0
  (count_update1-1 nil 3799389970
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = add(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_add")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (card_add formula-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil))
   shostak))
 (count_update2 0
  (count_update2-1 nil 3799389749
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = remove(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_remove")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil))
   shostak))
 (count_update3 0
  (count_update3-1 nil 3799420828
   ("" (skeep)
    (("" (expand "count")
      ((""
        (case "{i_1: below(len) | P(A WITH [(i) := u](i_1))} = remove(i, {i: below(len) | P(A(i))})")
        (("1" (replace -1 :hide? t)
          (("1" (rewrite "card_remove")
            (("1" (grind) nil nil)
             ("2"
              (rewrite "finite_subset" :subst
               ("A" "{i: below(len) | TRUE}"))
              (("1" (grind) nil nil)
               ("2" (hide-all-but 1)
                (("2" (expand "is_finite")
                  (("2" (inst + "len" "LAMBDA (i: below(len)): i")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 3) (("2" (grind-with-ext) nil nil)) nil))
        nil))
      nil))
    nil)
   ((count const-decl "upto(len)" arrayCount nil)
    (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (finite_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_remove formula-decl nil finite_sets nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (set type-eq-decl nil sets nil) (remove const-decl "set" sets nil))
   shostak)))


$$$pegtopdown.pvs
pegtopdown  % [ parameters ]
		: THEORY

  BEGIN


strings(len: uint16): TYPE = {s : bytestring | s`length = len} %[below(len) -> byte]
num_non_terminals: byte = 255
non_terminal: TYPE = below(num_non_terminals)



ent: DATATYPE
  BEGIN
  fail(dep: uint64): fail?
  pending: pending?
  loop: loop?
  good(dep: uint64, span: uint16): good?
  push(pos: uint16, nt: uint8): push?
  END ent

peg  : DATATYPE
  BEGIN
   epsilon : epsilon?
   failure : failure?
   any(p : [byte -> bool]) : any?
   terminal(a: byte) : terminal?
   concat(e1, e2: non_terminal) : concat?
   choice(e1, e2: non_terminal) : or?
   check(e: non_terminal) : and?
   neg(e: non_terminal) : not?
  END peg

len: VAR uint16 %the length of the input

JUDGEMENT upto(len) SUBTYPE_OF uint16
JUDGEMENT non_terminal SUBTYPE_OF uint8

%The scaffold entry can be fail, loop, good(span), or pending.
good_good_entry?(len, (pos: upto(len)))(x: (good?)): bool =  (pos + span(x) <= len)

%nt(x) = num_non_terminals at the end of the list. 
good_push_entry?(len)(x: ent): bool = (push?(x) AND pos(x) <= len AND nt(x) <= num_non_terminals)

fine_push_entry?(len)(x: ent): bool = good_push_entry?(len)(x) AND nt(x) < num_non_terminals

nice_entry?(len, (pos: upto(len)))(x: ent): bool =
    (good?(x) => good_good_entry?(len, pos)(x)) AND (push?(x) => good_push_entry?(len)(x))
    
scaffold(len) : TYPE = [pos: upto(len) -> [non_terminal -> (nice_entry?(len, pos))]]

m, n: VAR non_terminal

loop_or_push?(e: ent): bool = (loop?(e) or push?(e))

lang_spec: TYPE = [non_terminal -> peg]

G: VAR lang_spec

instack(len, (A : scaffold(len)))(pos: upto(len), nt: non_terminal):  bool =
   push?(A(pos)(nt))

f: VAR {g : [(push?) -> uint64] | FORALL (x : (push?)): nt(x) = num_non_terminals IMPLIES g(x) = 0}

successor(len, G, (A: scaffold(len)))(entry1, entry2: (good_push_entry?(len))): bool =
  (LET p1 = pos(entry1),
       nt1 = nt(entry1),
       p2 = pos(entry2),
       nt2 = nt(entry2)
     IN nt1 >= num_non_terminals
        OR CASES G(nt1) OF
           concat(n1, n2):  (p2 = p1 AND nt2 = n1) OR
	                   (good?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1 + span(A(p1)(n1))),
           choice(n1, n2): (p2 = p1 AND nt2 = n1) OR
	                   (fail?(A(p1)(n1)) AND nt2 = n2 AND p2 = p1),
           check(n1): (nt2 = n1 AND p2 = p1),
  	   neg(n1): (nt2 = n1 AND p2 = p1)
           ELSE FALSE
	   ENDCASES)

depth: VAR uint64

root, stack: VAR (push?)

IMPORTING  arrayCount
IMPORTING reals@sigma


sigma_restrict: LEMMA
   (FORALL (A: scaffold(len)), (j, k: upto(len)):
   j <= k => 
 sigma(0, j, LAMBDA (i: upto(j)) : count(num_non_terminals)(push?)(A(i))) =
 sigma(0, j, LAMBDA (i: upto(k)) : count(num_non_terminals)(push?)(A(i))))

sigma_restrict_len: LEMMA
   (FORALL (A: scaffold(len)), (j: upto(len)):
  sigma(0, j, LAMBDA (i: upto(j)) : count(num_non_terminals)(push?)(A(i))) =
 sigma(0, j, LAMBDA (i: upto(len)) : count(num_non_terminals)(push?)(A(i))))


sigma_nat: LEMMA
(FORALL (i: upto(len)), (F: [upto(len) -> nat]): 
      sigma(0, i, F) >= 0)

sigma_pos: LEMMA
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         F(i) > 0 AND j >= i IMPLIES sigma(0, j, F) > 0)

sigma_dec: LEMMA
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         F(i) > 0 IMPLIES 
         sigma(0, j, F WITH [(i) := F(i) - 1]) = (IF j < i THEN sigma(0, j, F) ELSE sigma(0, j, F) - 1 ENDIF))

sigma_inc: LEMMA 
      (FORALL (F: [upto(len) -> nat]), (i, j: upto(len)):
         sigma(0, j, F WITH [(i) := F(i) + 1]) = (IF j < i THEN sigma(0, j, F) ELSE sigma(0, j, F) + 1 ENDIF))

scafcount(len, (A: scaffold(len)), (P: [ent->bool]), (j: upto(len))): uint64 = sigma(0, j, LAMBDA (i: upto(len)) : count(num_non_terminals)(P)(A(i)))

sigma_max: LEMMA
   (FORALL (A: scaffold(len), (P: [ent -> bool]), (j: uint16)):
     j <= len => 
      scafcount(len, A, P, j) <= (j + 1) * num_non_terminals)

scafcount_max: LEMMA
(FORALL (A: scaffold(len), (P: [ent -> bool]), (j: uint16)):
     j <= len => 
      scafcount(len, A, P, j) <= exp2(40))
   

scafcount0: LEMMA
 (FORALL len, (A: scaffold(len)), (P: [ent->bool]): 
    scafcount(len, A, P, 0) = count(num_non_terminals)(P)(A(0)))

scafcount_step: LEMMA
  (FORALL len, (A: scaffold(len)), (P: [ent->bool]), (j: below(len)): 
    scafcount(len, A, P, j+1) = count(num_non_terminals)(P)(A(j+1)) + scafcount(len, A, P, j))

scafcount_update: LEMMA
 (FORALL len, (A: scaffold(len)), (P: [ent->bool]), (i, j: upto(len)), (n: non_terminal), (u: (nice_entry?(len, i))):
   scafcount(len, A WITH [(i)(n) := u], P, j) =
   IF i > j THEN scafcount(len, A, P, j)
   ELSIF P(u) THEN
        IF P(A(i)(n)) THEN scafcount(len, A, P, j) ELSE scafcount(len, A, P, j) + 1 ENDIF
   ELSIF P(A(i)(n)) THEN scafcount(len, A, P, j) - 1 ELSE scafcount(len, A, P, j) ENDIF)

pushcount(len, (A: scaffold(len))): uint64 = scafcount(len, A, push?, len)

good_or_fail?(entry: ent): bool = (good?(entry) OR fail?(entry))

gfcount(len, (A: scaffold(len))): uint64 = scafcount(len, A, good_or_fail?, len)

good_depth?(len, (A : scaffold(len)))(depth: uint64): bool =
  (pushcount(len, A) = depth)

good_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_push_entry?(len))):
   RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN depth = 0
     ELSE LET entry = A(pos(stack))(nt(stack))
	    IN good_push_entry?(len)(entry)
	       AND (nt(entry) = num_non_terminals OR successor(len, G, A)(entry, stack))
	            AND depth > 0 AND 
	              good_stack?(len, G, depth - 1, A)(entry)
    ENDIF)
    MEASURE depth

mem_stack?(len, G, depth, (A : scaffold(len)))(entry: (fine_push_entry?(len)), stack: (good_stack?(len, G, depth, A))): RECURSIVE bool
 = (IF nt(stack) >= num_non_terminals
     THEN FALSE
     ELSE entry = stack OR mem_stack?(len, G, depth - 1, A)(entry, A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

mem_stack_push: LEMMA
  (FORALL (A: scaffold(len)), (entry: (fine_push_entry?(len))), (stack:  (good_stack?(len, G, depth, A))):
    good_stack?(len, G, depth, A)(stack) AND 
    mem_stack?(len, G, depth, A)(entry, stack) => push?(A(pos(entry))(nt(entry))))

push_or_pending?(entry: ent): bool =
  push?(entry) OR pending?(entry)

good_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, stack: (good_push_entry?(len))), (u: (nice_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   fine_push_entry?(len)(entry) AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push_or_pending?(A(pos(entry))(nt(entry)))
   IMPLIES good_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(stack))

mem_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, v, stack: (good_push_entry?(len))), (u: (nice_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   fine_push_entry?(len)(entry) AND fine_push_entry?(len)(v) AND
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push_or_pending?(A(pos(entry))(nt(entry)))
   IMPLIES mem_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(v, stack)
           = mem_stack?(len, G, depth, A)(v, stack))

good_mem_stack_push: LEMMA
  (FORALL (A: scaffold(len)), (pos: upto(len)),  (stack: (good_push_entry?(len))):
   depth <= exp2(40) AND 
   good_stack?(len, G, depth, A)(stack) AND
   pending?(A(pos)(n)) AND
   successor(len, G, A)(stack, push(pos, n))
   IMPLIES good_stack?(len, G, depth + 1, A WITH [(pos)(n) := stack])(push(pos, n)))



fine_stack?(len, G, depth, (A: scaffold(len)))(stack: (good_stack?(len, G, depth, A))): RECURSIVE bool =
   (IF nt(stack) >= num_non_terminals
     THEN TRUE
     ELSE LET rest = A(pos(stack))(nt(stack))
          IN NOT mem_stack?(len, G, depth - 1, A)(stack, rest) AND
             fine_stack?(len, G, depth - 1, A)(A(pos(stack))(nt(stack)))
    ENDIF)
    MEASURE depth

fine_mem_stack: LEMMA
  (FORALL (A: scaffold(len)), (entry, stack: (good_push_entry?(len))), (u: (nice_entry?(len, (pos(entry))))): 
   good_stack?(len, G, depth, A)(stack) AND
   fine_push_entry?(len)(entry) AND 
   NOT mem_stack?(len, G, depth, A)(entry, stack) AND
   push_or_pending?(A(pos(entry))(nt(entry)))
   IMPLIES fine_stack?(len, G, depth, A WITH [(pos(entry))(nt(entry)):= u])(stack)
           = fine_stack?(len, G, depth, A)(stack))

% dgood?(d: uint64, u: ent): bool = good?(u) AND dep(u) < d
% dfail?(d: uint64, u: ent): bool = fail?(u) AND dep(u) < d

loop_ready?(len, G, (A: scaffold(len)), (i: upto(len)), n): bool =
   (CASES G(n) OF
           concat(n1, n2):  loop_or_push?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop_or_push?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop_or_push?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop_or_push?(A(i)(n2))),
           check(n1): loop_or_push?(A(i)(n1)),
  	   neg(n1): loop_or_push?(A(i)(n1))
           ELSE FALSE
       ENDCASES)
   				       
good_fail?(len, G, (s: strings(len)))((A: scaffold(len)), (i : upto(len)), n, (d: uint64)): bool =
  (CASES G(n) OF
           any(p): (i = len OR NOT p(s(i))) AND d = 0,
           terminal(a): (i = len OR a /= s(i)) AND d = 0,
           concat(n1, n2):  (fail?(A(i)(n1)) AND d = 1 + dep(A(i)(n1))) OR
                             (good?(A(i)(n1)) AND 
  			      fail?(A(i + span(A(i)(n1)))(n2)) AND d = 1 + max(dep(A(i)(n1)), dep(A(i + span(A(i)(n1)))(n2)))),
           choice(n1, n2): fail?(A(i)(n1)) AND fail?(A(i)(n2)) AND d = 1 + max(dep(A(i)(n1)), dep(A(i)(n2))),
           check(n1): fail?(A(i)(n1)) AND d = 1 + dep(A(i)(n1)),
  	   neg(n1): good?(A(i)(n1)) AND d = 1 + dep(A(i)(n1)),
  	   failure: d = 0
           ELSE FALSE
       ENDCASES)

good_loop?(len, G)(A: scaffold(len), (i: upto(len)), n): bool =
(CASES G(n) OF
           concat(n1, n2):  loop?(A(i)(n1)) or
  	                    (good?(A(i)(n1)) 
  			     AND loop?(A(i + span(A(i)(n1)))(n2))),
           choice(n1, n2): loop?(A(i)(n1)) or (fail?(A(i)(n1)) AND loop?(A(i)(n2))),
           check(n1): loop?(A(i)(n1)),
  	   neg(n1): loop?(A(i)(n1))
           ELSE FALSE
       ENDCASES)

good_good?(len, G, (s: strings(len)))((A: scaffold(len)), (i: upto(len)), n, (d: uint64), (sp :upto(len - i))): bool =
 (CASES G(n) OF
         epsilon: sp = 0 AND d = 0,
  	 any(p): sp = 1 AND p(s(i)) AND d = 0,
  	 terminal(a): sp = 1 AND s(i) = a AND d = 0,
  	 concat(n1, n2): good?(A(i)(n1)) 
  	                 AND good?(A(i + span(A(i)(n1)))(n2)) AND d = 1 + max(dep(A(i)(n1)), dep(A(i + span(A(i)(n1)))(n2))),
  	 choice(n1, n2): (good?(A(i)(n1)) AND d = 1 + dep(A(i)(n1)))
	                OR (fail?(A(i)(n1)) AND good?(A(i)(n2)) AND d = 1 + max(dep(A(i)(n1)), dep(A(i)(n2)))),
  	 check(n1): good?(A(i)(n1)) AND sp = 0 AND d = 1 + dep(A(i)(n1)),
  	 neg(n1): fail?(A(i)(n1)) AND sp = 0 AND d = 1 + dep(A(i)(n1)),
  	 failure: FALSE
  	 ENDCASES)

good_entry?(len, G, (s: strings(len)))(A : scaffold(len), (i : upto(len)), n, (u: ent)): bool =
   CASES u OF
    fail(d): good_fail?(len, G, s)(A, i, n, d),
    loop: loop_ready?(len, G, A,  i, n), %don't need good_loop?
    good(d, sp):  sp <= len - i AND good_good?(len, G, s)(A, i, n, d, sp)
    ELSE TRUE
    ENDCASES

fine_entry?(len, G, (s: strings(len)))(A : scaffold(len), (i : upto(len)), n, (u: ent)): bool =
   CASES u OF
    fail(d): good_fail?(len, G, s)(A, i, n, d),
    loop: loop_ready?(len, G, A,  i, n), %don't need good_loop?
    good(d, sp):  sp <= len - i AND good_good?(len, G, s)(A, i, n, d, sp)
    ELSE fine_push_entry?(len)(u) AND push_or_pending?(A(pos(u))(nt(u)))
    ENDCASES

finer_entry?(len, G, (s: strings(len)))(A : scaffold(len), (stack: (good_push_entry?(len))), (i : upto(len)), n, (u: ent)): bool =
  fine_entry?(len, G, s)(A, i, n, u) AND
  (push?(u) IMPLIES pending?(A(pos(u))(nt(u))) AND successor(len, G, A)(stack, u))

good_tscaffold?(len, G, (s: strings(len)))(A : scaffold(len)): bool =
 (FORALL (i: upto(len)), n: good_entry?(len, G, s)(A, i, n, A(i)(n)) AND
              (good_or_fail?(A(i)(n)) => dep(A(i)(n)) <= gfcount(len, A)))

% full_stack?(len, G, depth, (A : scaffold(len)))(stack: (good_stack?(len, G, depth, A))): bool =
%    (FORALL (pos: upto(len)), m : instack(len, A)(pos, m) => mem_stack?(len, G, depth, A)(push(pos, m), stack))

good_root?(len, (A: scaffold(len)))((rootpos: upto(len)), rootnt : non_terminal): bool =
  (NOT pending?(A(rootpos)(rootnt)))

fine_scaffold?(len, G, (s: strings(len)))((rootpos : upto(len)), (rootnt: non_terminal))(A : scaffold(len)): bool =
         good_root?(len, A)(rootpos, rootnt) AND
   good_tscaffold?(len, G, s)(A)

good_good_tscaffold: LEMMA
  (FORALL (s: strings(len)), (A: scaffold(len)), (pos: upto(len)), (nt: non_terminal), (u: (nice_entry?(len, pos))):
   push_or_pending?(A(pos)(nt)) AND
   good_tscaffold?(len, G, s)(A) AND
   fine_entry?(len, G, s)(A, pos, nt, u) AND
   (FORALL (j: upto(len)), m: loop?(A(j)(m)) IMPLIES loop_ready?(len, G, A, pos, nt))
   IMPLIES good_tscaffold?(len, G, s)(A WITH [(pos)(nt):= u]))

% fine_scaffold(len, G, s : strings(len))(rootpos: upto(len), rootnt : non_terminal)): TYPE
%  = (fine_scaffold(len, G, s)(rootpos, rootnt))

% update_entry(len, G, s: strings(len))(rootpos : upto(len), rootnt: non_terminal)(A : fine_scaffold(len, G, s)(rootpos, rootnt), entry: (good_push_entry?(len)), u : (fine_entry?(len, G, s)(A, pos(entry), nt(entry)): fine_scaffold(len, G, s)(rootpos, rootnt)
%  = A WITH [(pos(entry))(nt(entry)):= u]





state(len, G, (s: strings(len)), (rootpos: upto(len)), (rootnt: non_terminal)): TYPE
    = [# scaf: (fine_scaffold?(len, G, s)(rootpos, rootnt)), 
         depth: (good_depth?(len, scaf)),
	 stack: (fine_stack?(len, G, depth, scaf)),
	 lflag: {b: bool | IF b
	                     THEN nt(stack) = num_non_terminals OR loop_ready?(len, G, scaf, pos(stack), nt(stack))
			     ELSE (FORALL (i: upto(len)), n: NOT loop?(scaf(i)(n))) ENDIF}
	#]
         

empty?(stack): bool = (nt(stack) = num_non_terminals)

ne_state(len, G, (s: strings(len)), (rootpos: upto(len)), (rootnt: non_terminal)): TYPE
 = {st: state(len, G, s, rootpos, rootnt) |  NOT empty?(st`stack)}

% putstack(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St: state(len, G, s, start, root) | NOT empty?(St`stack))((pos: upto(len)), (n| (pending?(St`scaf(pos)(n)) OR push?(St`scaf(pos)(n))) AND successor(len, G, St`scaf)(St`stack, push(pos, n))))
%    : state(len, G, s, start, root)
%  = (IF instack(len, St`scaf)(pos, n)
%        THEN St WITH [`scaf(pos)(n) := loop]
%        ELSE St WITH [`stack := push(pos, n), depth := St`depth + 1, `scaf(pos)(n) := St`stack]
%        ENDIF)

finer_entry(len, G, (s: strings(len)), (A: scaffold(len)), (stack : (good_push_entry?(len))), (pos : upto(len)), (nt: non_terminal)): TYPE = {u : ent | finer_entry?(len, G, s)(A, stack, pos, nt, u)}

newentry(len, G, (s: strings(len)), (start: upto(len)), (rootnt: non_terminal))(St : ne_state(len, G, s, start, rootnt)):
   finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))
   =
    (LET pos = pos(St`stack),
         cur = nt(St`stack),
         rest = St`scaf(pos)(cur)
     IN CASES G(cur) OF
         epsilon: good(0, 0),
         failure: fail(0),
         any(p): IF pos = len OR NOT p(s(pos)) THEN fail(0) ELSE good(0, 1) ENDIF,
         terminal(a): IF pos = len OR a /= s(pos) THEN fail(0) ELSE good(0, 1) ENDIF,
         concat(n1, n2): (CASES St`scaf(pos)(n1) OF
	                    fail(d1): fail(d1+1), 
   		            good(d1, sp): CASES St`scaf(pos + sp)(n2) OF
			                   fail(d2): fail(1 + max(d1, d2)),
					   good(d2, sp2): good(1+max(d1, d2), sp + sp2), 
					   pending: push(pos + sp, n2) 
					   ELSE loop
					ENDCASES,
			      pending: push(pos, n1)
			      ELSE loop
			      ENDCASES),
	    choice(n1, n2): (CASES St`scaf(pos)(n1) OF
	                      fail(d1): CASES St`scaf(pos)(n2) OF
			                   fail(d2): fail(max(d1,d2)+1), 
					   good(d2, sp): good(max(d1, d2) + 1, sp),
					   pending: push(pos, n2) 
					   ELSE loop
					ENDCASES,
			      good(d1, sp): good(d1+1, sp), 
			      pending: push(pos, n1) 
			      ELSE loop 
			      ENDCASES),
	    check(n1): (CASES St`scaf(pos)(n1) OF
	                      fail(d1): fail(d1+1), 
			      good(d1, sp): good(d1+1, 0), 
			      pending: push(pos, n1) 
			      ELSE loop
			      ENDCASES),
	    neg(n1): (CASES St`scaf(pos)(n1) OF
	                      fail(d1): good(d1+1, 0),
			      good(d1, sp): fail(d1+1), 
			      pending: push(pos, n1)
			      ELSE loop
			      ENDCASES)
          ENDCASES)			      
   
  

step(len, G, (s: strings(len)), (start: upto(len)), (rootnt: non_terminal))(St : state(len, G, s, start, rootnt)): state(len, G, s, start, rootnt)
 = (LET scaf = St`scaf,
	stack = St`stack,
	depth = St`depth,
	lflag = St`lflag
     IN
    IF empty?(stack)
    THEN St
    ELSE LET pos = pos(stack),
             cur = nt(stack),
	     rest = scaf(pos)(cur),
	     newentry = newentry(len, G, s, start, rootnt)(St)
	  IN CASES newentry OF
	       push(p, n): St WITH [`scaf(p)(n) := stack, `stack := newentry, `depth := depth + 1]
	       ELSE St WITH [`scaf(pos)(cur) := newentry, `stack := rest, `depth := depth - 1, `lflag := loop?(newentry)]
	       ENDCASES
    ENDIF)


 size(len, G, (s: strings(len)), pos: upto(len), n)(St : state(len, G, s, pos, n)): ordinal
  =
    lex2(scafcount(len, St`scaf, push_or_pending?, len), 
         ((len + 1) * num_non_terminals) - St`depth)

 endstate(len, G, (s: strings(len)), (rootpos: upto(len)), (rootnt: non_terminal)): TYPE
  = {st: state(len, G, s, rootpos, rootnt) |
      empty?(st`stack)}


 parse(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St : state(len, G, s, start, root)): RECURSIVE endstate(len, G, s, start, root)
  = (IF St`depth = 0
      THEN St
      ELSE parse(len, G, s, start, root)(step(len, G, s, start, root)(St))
      ENDIF)
      MEASURE size(len, G, s, start, root)(St) BY <

 doparse(len, G, (s: strings(len)), n): ent
   = (LET pend = (LAMBDA n: pending),
          St: state(len, G, s, 0, n) = (# 
 		 stack := push(0, n),
		 depth := 1,
 		 scaf := (LAMBDA (i: upto(len)): pend) WITH [(0)(n) := push(0, num_non_terminals)],
		 lflag := FALSE #)
      IN parse(len, G, s, 0, n)(St)`scaf(0)(n))

  END pegtopdown

$$$pegtopdown.prf
(pegtopdown
 (subtype_TCC1 0
  (subtype_TCC1-1 nil 3809020225 ("" (judgement-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (subtype_ subtype "pegtopdown.x" "uint32")))
 (subtype_TCC2 0
  (subtype_TCC2-1 nil 3809020225 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (exp2 def-decl "posnat" exp2 nil))
   nil (subtype_ subtype "pegtopdown.x" "uint8")))
 (fine_push_entry?_TCC1 0
  (fine_push_entry?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (fine_push_entry? subtype "pegtopdown.x" "(pegtopdown.push?)")))
 (successor_TCC1 0
  (successor_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "pegtopdown.entry1" "(pegtopdown.push?)")))
 (successor_TCC2 0
  (successor_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "pegtopdown.entry2" "(pegtopdown.push?)")))
 (successor_TCC3 0
  (successor_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (successor subtype "pegtopdown.nt1" "non_terminal")))
 (successor_TCC4 0
  (successor_TCC4-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (successor subtype "pegtopdown.p1"
    "naturalnumbers.upto(pegtopdown.len)")))
 (successor_TCC5 0
  (successor_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (successor subtype "pegtopdown.p1"
    "naturalnumbers.upto(pegtopdown.len)")))
 (sigma_restrict_TCC1 0
  (sigma_restrict_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict subtype "0" "T_low[upto(j)]")))
 (sigma_restrict_TCC2 0
  (sigma_restrict_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict subtype "pegtopdown.j" "T_high[upto(j)]")))
 (sigma_restrict_TCC3 0
  (sigma_restrict_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict subtype "pegtopdown.i"
    "naturalnumbers.upto(pegtopdown.len)")))
 (sigma_restrict_TCC4 0
  (sigma_restrict_TCC4-1 nil 3809020225 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (integer nonempty-type-from-decl nil integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (sigma_restrict assuming
    "reals@sigma[naturalnumbers.upto(pegtopdown.j)].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_restrict_TCC5 0
  (sigma_restrict_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict subtype "0" "T_low[upto(k)]")))
 (sigma_restrict_TCC6 0
  (sigma_restrict_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (sigma_restrict subtype "pegtopdown.j" "T_high[upto(k)]")))
 (sigma_restrict_TCC7 0
  (sigma_restrict_TCC7-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict subtype "pegtopdown.i"
    "naturalnumbers.upto(pegtopdown.len)")))
 (sigma_restrict_TCC8 0
  (sigma_restrict_TCC8-1 nil 3809020225 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (integer nonempty-type-from-decl nil integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (sigma_restrict assuming
    "reals@sigma[naturalnumbers.upto(pegtopdown.k)].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_restrict 0
  (sigma_restrict-1 nil 3809140910
   ("" (skolem + ("len" "A" "_" "_"))
    (("" (induct j)
      (("1" (grind) nil nil)
       ("2" (skeep*)
        (("2" (expand "sigma" +)
          (("2" (inst-cp - k)
            (("2" (inst - "jt + 1")
              (("1" (ground) nil nil) ("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil)
       ("3" (hide 2) (("3" (grind) nil nil)) nil)
       ("4" (hide 2) (("4" (grind) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (integer nonempty-type-from-decl nil integers nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (ent type-decl nil pegtopdown nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (arr type-eq-decl nil arrayCount nil)
    (count const-decl "upto(len)" arrayCount nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (jt skolem-const-decl "upto(len)" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (sigma_restrict_len_TCC1 0
  (sigma_restrict_len_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict_len subtype "0" "T_low[upto(j)]")))
 (sigma_restrict_len_TCC2 0
  (sigma_restrict_len_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict_len subtype "pegtopdown.j" "T_high[upto(j)]")))
 (sigma_restrict_len_TCC3 0
  (sigma_restrict_len_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict_len subtype "pegtopdown.i"
    "naturalnumbers.upto(pegtopdown.len)")))
 (sigma_restrict_len_TCC4 0
  (sigma_restrict_len_TCC4-1 nil 3809020225 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (sigma_restrict_len assuming
    "reals@sigma[naturalnumbers.upto(pegtopdown.j)].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_restrict_len_TCC5 0
  (sigma_restrict_len_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict_len subtype "0" "T_low[upto(len)]")))
 (sigma_restrict_len_TCC6 0
  (sigma_restrict_len_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_restrict_len subtype "pegtopdown.j" "T_high[upto(len)]")))
 (sigma_restrict_len_TCC7 0
  (sigma_restrict_len_TCC7-1 nil 3809020225 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (sigma_restrict_len assuming
    "reals@sigma[naturalnumbers.upto(pegtopdown.len)].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (sigma_restrict_len 0
  (sigma_restrict_len-1 nil 3809140924
   ("" (skeep*)
    (("" (lemma "sigma_restrict")
      (("" (inst - len A j len) (("" (ground) nil nil)) nil)) nil))
    nil)
   ((sigma_restrict formula-decl nil pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (sigma_nat_TCC1 0
  (sigma_nat_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_nat subtype "0" "T_low[upto(len)]")))
 (sigma_nat_TCC2 0
  (sigma_nat_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_nat subtype "pegtopdown.i" "T_high[upto(len)]")))
 (sigma_nat 0
  (sigma_nat-1 nil 3809140941
   ("" (skolem + ("len" _ _)) (("" (induct-and-simplify i) nil nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (sigma_pos_TCC1 0
  (sigma_pos_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_pos subtype "pegtopdown.j" "T_high[upto(len)]")))
 (sigma_pos 0
  (sigma_pos-1 nil 3809140965
   ("" (skolem + ("len" _ _ _)) (("" (induct-and-simplify j) nil nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (sigma_dec_TCC1 0
  (sigma_dec_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_dec subtype "pegtopdown.j" "T_high[upto(len)]")))
 (sigma_dec 0
  (sigma_dec-1 nil 3809140983
   ("" (skolem + ("len" _ _ _))
    (("" (induct "j")
      (("1" (grind) nil nil)
       ("2" (skeep*)
        (("2" (expand sigma +) (("2" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (sigma_inc_TCC1 0
  (sigma_inc_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_inc subtype "pegtopdown.j" "T_high[upto(len)]")))
 (sigma_inc_TCC2 0
  (sigma_inc_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (sigma_inc subtype "pegtopdown.j" "T_high[upto(len)]")))
 (sigma_inc 0
  (sigma_inc-1 nil 3809140999
   ("" (skolem + ("len" _ _ _))
    (("" (induct "j") (("1" (grind) nil nil) ("2" (grind) nil nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (scafcount_TCC1 0
  (scafcount_TCC1-1 nil 3809020225
   ("" (skolem + (len A P "_"))
    ((""
      (case "FORALL ((j: upto(len))):
               sigma[upto(len)]
                   (0, j,
                    LAMBDA (i: upto(len)): count[ent](num_non_terminals)(P)(A(i)))
                <= (j + 1) * num_non_terminals")
      (("1" (skeep)
        (("1" (inst?)
          (("1" (case "(j + 1) * num_non_terminals <= exp2(64) - 1")
            (("1" (assert) nil nil)
             ("2" (hide -1 2)
              (("2"
                (use le_times_le_pos :subst
                     (nnx "j + 1" y "exp2(32)" nnz num_non_terminals w
                      "exp2(8)"))
                (("2" (ground)
                  (("1" (rewrite exp2_sum :dir RL)
                    (("1" (grind) nil nil)) nil)
                   ("2" (assert)
                    (("2" (typepred "num_non_terminals")
                      (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (induct-and-simplify j :exclude count) nil nil)) nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (arr type-eq-decl nil arrayCount nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (ent type-decl nil pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (exp2_sum formula-decl nil exp2 nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (pred type-eq-decl nil defined_types nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (scafcount subtype
    "sigma[naturalnumbers.upto(pegtopdown.len)].sigma(0, pegtopdown.j, LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): arrayCount[pegtopdown.ent].count(pegtopdown.num_non_terminals)(pegtopdown.P)(pegtopdown.A(i)))"
    "uint64")))
 (sigma_max 0
  (sigma_max-1 nil 3809141021
   ("" (induct j)
    (("1" (skeep)
      (("1" (expand scafcount)
        (("1" (expand "sigma" +)
          (("1" (expand "sigma" +)
            (("1" (typepred "count(num_non_terminals)(push?)(A(0))")
              (("1" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (expand scafcount)
        (("2" (expand "sigma" +)
          (("2" (inst - len A P) (("2" (ground) nil nil)) nil)) nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (sigma def-decl "real" sigma reals)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (arr type-eq-decl nil arrayCount nil)
    (count const-decl "upto(len)" arrayCount nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (pred type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (scafcount_max 0
  (scafcount_max-1 nil 3809141042
   ("" (skeep*)
    (("" (use sigma_max)
      (("" (use "le_times_le_pos" :subst (y "exp2(32)" w "exp2(8)"))
        (("" (ground)
          (("1" (rewrite exp2_sum :dir RL) (("1" (assert) nil nil))
            nil)
           ("2" (assert)
            (("2" (typepred num_non_terminals) (("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sigma_max formula-decl nil pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (exp2_sum formula-decl nil exp2 nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (scafcount0_TCC1 0
  (scafcount0_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (scafcount0 subtype "0" "naturalnumbers.upto(pegtopdown.len)")))
 (scafcount0 0
  (scafcount0-1 nil 3809141062
   ("" (grind :rewrites count_update00) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (num_non_terminals const-decl "byte" pegtopdown nil))
   shostak))
 (scafcount_step_TCC1 0
  (scafcount_step_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (scafcount_step subtype "(number_fields.+)(pegtopdown.j, 1)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (scafcount_step_TCC2 0
  (scafcount_step_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (scafcount_step subtype "pegtopdown.j"
    "naturalnumbers.upto(pegtopdown.len)")))
 (scafcount_step 0
  (scafcount_step-1 nil 3809141079
   ("" (skolem + (len "_" "_" "_"))
    (("" (induct "j")
      (("1" (grind) nil nil)
       ("2" (skeep*)
        (("2" (expand "scafcount" +)
          (("2" (inst?) (("2" (inst?) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint64 type-eq-decl nil integertypes nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (arr type-eq-decl nil arrayCount nil)
    (count const-decl "upto(len)" arrayCount nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (sigma def-decl "real" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (scafcount_update 0
  (scafcount_update-1 nil 3809141098
   ("" (skolem + (len "_" "_" "_" "_" "_" "_"))
    (("" (induct j)
      (("1" (skeep*)
        (("1" (rewrite scafcount0)
          (("1" (lift-if :updates? nil)
            (("1" (ground)
              (("1" (grind) nil nil)
               ("2" (case "i  = 0")
                (("1" (assert)
                  (("1" (rewrite count_update00)
                    (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (assert) nil nil))
                nil)
               ("3" (case "i  = 0")
                (("1" (assert)
                  (("1" (rewrite count_update00)
                    (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (case "i  = 0")
                  (("1" (propax) nil nil) ("2" (assert) nil nil)) nil))
                nil)
               ("4" (case "i  = 0")
                (("1" (assert)
                  (("1" (rewrite count_update00)
                    (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (case "i  = 0")
                  (("1" (propax) nil nil) ("2" (grind) nil nil)) nil))
                nil)
               ("5" (case "i  = 0")
                (("1" (assert)
                  (("1" (rewrite count_update00)
                    (("1" (grind) nil nil)) nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep*)
        (("2" (rewrite scafcount_step)
          (("2" (rewrite -2)
            (("2" (hide -2)
              (("2" (case "i = 1 + jt")
                (("1" (assert)
                  (("1" (rewrite count_update00)
                    (("1"
                      (grind :rewrites scafcount_step :exclude count)
                      nil nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (grind :rewrites scafcount_step :exclude count)
                    nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (uint64 type-eq-decl nil integertypes nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (scafcount0 formula-decl nil pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (count_update00 formula-decl nil arrayCount nil)
    (below type-eq-decl nil naturalnumbers nil)
    (arr type-eq-decl nil arrayCount nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scafcount_step formula-decl nil pegtopdown nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (pushcount_TCC1 0
  (pushcount_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (pushcount subtype "pegtopdown.len"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_stack?_TCC1 0
  (good_stack?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_stack? subtype "pegtopdown.stack" "(pegtopdown.push?)")))
 (good_stack?_TCC2 0
  (good_stack?_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_stack? subtype "pegtopdown.entry" "(pegtopdown.push?)")))
 (good_stack?_TCC3 0
  (good_stack?_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "(number_fields.-)(pegtopdown.depth, 1)"
    "uint64")))
 (good_stack?_TCC4 0
  (good_stack?_TCC4-1 nil 3809020225 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? termination
    "pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A)"
    "nil")))
 (good_stack?_TCC5 0
  (good_stack?_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "pegtopdown.nt(pegtopdown.stack)"
    "non_terminal")))
 (good_stack?_TCC6 0
  (good_stack?_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_stack? subtype "pegtopdown.pos(pegtopdown.stack)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (mem_stack?_TCC1 0
  (mem_stack?_TCC1-1 nil 3809020225
   ("" (skeep* :preds? t)
    (("" (expand "good_stack?") (("" (ground) nil nil)) nil)) nil)
   ((good_stack? def-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? subtype "(number_fields.-)(pegtopdown.depth, 1)"
    "uint64")))
 (mem_stack?_TCC2 0
  (mem_stack?_TCC2-1 nil 3809020225 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? termination
    "pegtopdown.mem_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A)"
    "nil")))
 (mem_stack?_TCC3 0
  (mem_stack?_TCC3-1 nil 3809020225 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack? subtype
    "pegtopdown.A(pegtopdown.pos(pegtopdown.stack))(pegtopdown.nt(pegtopdown.stack))"
    "(pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A))")))
 (mem_stack_push_TCC1 0
  (mem_stack_push_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack_push subtype "pegtopdown.entry" "(pegtopdown.push?)")))
 (mem_stack_push_TCC2 0
  (mem_stack_push_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack_push subtype "pegtopdown.nt(pegtopdown.entry)"
    "non_terminal")))
 (mem_stack_push_TCC3 0
  (mem_stack_push_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_stack_push subtype "pegtopdown.pos(pegtopdown.entry)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (mem_stack_push 0
  (mem_stack_push-1 nil 3809066760
   ("" (induct depth)
    (("1" (lazy-grind :defs nil) nil nil)
     ("2" (skeep*)
      (("2" (expand mem_stack?)
        (("2" (typepred stack) (("2" (grind) nil nil)) nil)) nil))
      nil)
     ("3" (skeep*)
      (("3" (expand mem_stack? -4)
        (("3" (ground)
          (("1" (typepred stack) (("1" (grind) nil nil)) nil)
           ("2" (inst?) (("2" (ground) nil nil)) nil))
          nil))
        nil))
      nil)
     ("4" (grind) nil nil)
     ("5" (hide 2)
      (("5" (skeep*)
        (("5" (typepred entry) (("5" (grind) nil nil)) nil)) nil))
      nil)
     ("6" (hide 2)
      (("6" (skeep*)
        (("6" (typepred entry) (("6" (grind) nil nil)) nil)) nil))
      nil)
     ("7" (hide 2) (("7" (grind) nil nil)) nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (<= const-decl "bool" reals nil)
    (uint64 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil))
   shostak))
 (good_mem_stack_TCC1 0
  (good_mem_stack_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack subtype "(pegtopdown.pos(pegtopdown.entry))"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_mem_stack_TCC2 0
  (good_mem_stack_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack subtype "pegtopdown.nt(pegtopdown.entry)"
    "non_terminal")))
 (good_mem_stack 0
  (good_mem_stack-1 nil 3809141149
   ("" (induct "depth")
    (("1" (grind)
      (("1" (expand "good_stack?") (("1" (propax) nil nil)) nil)
       ("2" (grind)
        (("2" (expand "good_stack?") (("2" (propax) nil nil)) nil))
        nil)
       ("3" (expand "good_stack?") (("3" (propax) nil nil)) nil)
       ("4" (expand good_stack?) (("4" (propax) nil nil)) nil)
       ("5" (expand good_stack?) (("5" (propax) nil nil)) nil)
       ("6" (expand good_stack?) (("6" (propax) nil nil)) nil))
      nil)
     ("2" (skeep*)
      (("2" (expand "mem_stack?" +)
        (("2" (ground)
          (("1" (typepred stack) (("1" (grind :if-match nil) nil nil))
            nil)
           ("2" (expand "good_stack?" :fnum (-3 4))
            (("2" (ground)
              (("1" (hide -3 4)
                (("1" (grind)
                  (("1" (typepred entry)
                    (("1" (grind)
                      (("1" (typepred stack)
                        (("1" (grind)
                          (("1" (extensionality "(push?)")
                            (("1" (inst?) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (extensionality "(push?)")
                    (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)
                   ("3" (extensionality "(push?)")
                    (("3" (inst?) (("3" (ground) nil nil)) nil)) nil))
                  nil))
                nil)
               ("2" (hide -3 2 5)
                (("2" (lift-if)
                  (("2" (ground)
                    (("2" (lift-if)
                      (("2" (ground)
                        (("2" (extensionality "(push?)")
                          (("2" (inst?) (("2" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (inst?)
                (("3" (ground)
                  (("1" (hide 2)
                    (("1" (lift-if)
                      (("1" (typepred entry)
                        (("1" (grind)
                          (("1" (extensionality "(push?)")
                            (("1" (inst?) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (lift-if)
                    (("2" (ground)
                      (("2" (ground)
                        (("2" (extensionality "(push?)")
                          (("2" (inst?) (("2" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (hide -3 4)
                (("4" (hide -1)
                  (("4" (lift-if)
                    (("4" (ground)
                      (("4" (ground)
                        (("4" (extensionality "(push?)")
                          (("4" (inst?) (("4" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (hide -3 5)
                (("5" (case "pos(stack) = pos(entry)")
                  (("1" (case "nt(stack) = nt(entry)")
                    (("1" (extensionality "(push?)")
                      (("1" (assert)
                        (("1" (inst?) (("1" (ground) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (typepred u) (("2" (grind) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil)
               ("6" (inst? :polarity? t)
                (("6" (ground)
                  (("1" (hide 2)
                    (("1" (lift-if)
                      (("1" (ground)
                        (("1" (ground)
                          (("1" (extensionality "(push?)")
                            (("1" (inst?) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (lift-if)
                    (("2" (ground)
                      (("2" (ground)
                        (("2" (extensionality "(push?)")
                          (("2" (inst?) (("2" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil)
     ("4" (hide 2) (("4" (grind) nil nil)) nil)
     ("5" (hide 2) (("5" (grind) nil nil)) nil)
     ("6" (hide 2) (("6" (grind) nil nil)) nil)
     ("7" (hide 2) (("7" (grind) nil nil)) nil)
     ("8" (hide 2) (("8" (grind) nil nil)) nil)
     ("9" (hide 2) (("9" (grind) nil nil)) nil)
     ("10" (hide 2) (("10" (grind) nil nil)) nil)
     ("11" (hide 2) (("11" (grind) nil nil)) nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ent_push_extensionality formula-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (pred type-eq-decl nil defined_types nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (<= const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil))
   shostak))
 (mem_mem_stack_TCC1 0
  (mem_mem_stack_TCC1-1 nil 3809020225
   ("" (skeep*)
    (("" (lemma good_mem_stack)
      (("" (inst?) (("" (ground) nil nil)) nil)) nil))
    nil)
   ((good_mem_stack formula-decl nil pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (mem_mem_stack subtype "pegtopdown.stack"
    "(pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, pegtopdown.depth, pegtopdown.A WITH [(pegtopdown.pos(pegtopdown.entry))(pegtopdown.nt(pegtopdown.entry)) := pegtopdown.u]))")))
 (mem_mem_stack 0
  (mem_mem_stack-1 nil 3809141402
   ("" (induct depth)
    (("1" (skeep*)
      (("1" (expand good_stack?) (("1" (grind) nil nil)) nil)) nil)
     ("2" (skeep*)
      (("2" (expand mem_stack? +)
        (("2" (lift-if)
          (("2" (ground)
            (("2" (case "v = stack")
              (("1" (assert) nil nil)
               ("2" (assert)
                (("2" (inst?)
                  (("2" (ground)
                    (("1" (lift-if -)
                      (("1" (ground)
                        (("1" (lift-if -)
                          (("1" (ground)
                            (("1" (extensionality "(push?)")
                              (("1"
                                (forward-chain -)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand good_stack? -)
                      (("2" (ground)
                        (("1" (case "pos(stack) = pos(entry)")
                          (("1" (case "nt(stack) = nt(entry)")
                            (("1" (assert)
                              (("1"
                                (extensionality "(push?)")
                                (("1"
                                  (inst - stack entry)
                                  (("1" (ground) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil)
                         ("2" (case "pos(stack) = pos(entry)")
                          (("1" (case "nt(stack) = nt(entry)")
                            (("1" (assert)
                              (("1"
                                (extensionality "(push?)")
                                (("1"
                                  (inst - stack entry)
                                  (("1" (ground) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("3" (case "pos(stack) = pos(entry)")
                      (("1" (case "nt(stack) = nt(entry)")
                        (("1" (extensionality "(push?)")
                          (("1" (inst - stack entry)
                            (("1" (ground) nil nil)) nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil)
     ("4" (hide 2) (("4" (grind) nil nil)) nil)
     ("5" (hide 2) (("5" (grind) nil nil)) nil)
     ("6" (hide 2)
      (("6" (skeep*)
        (("6" (use good_mem_stack) (("6" (ground) nil nil)) nil)) nil))
      nil)
     ("7" (hide 2)
      (("7" (skeep*)
        (("7" (typepred entry) (("7" (grind) nil nil)) nil)) nil))
      nil)
     ("8" (hide 2) (("8" (grind) nil nil)) nil)
     ("9" (hide 2) (("9" (grind) nil nil)) nil)
     ("10" (hide 2) (("10" (grind) nil nil)) nil)
     ("11" (hide 2) (("11" (grind) nil nil)) nil)
     ("12" (hide 2) (("12" (grind) nil nil)) nil))
    nil)
   ((good_mem_stack formula-decl nil pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ent_push_extensionality formula-decl nil pegtopdown nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (<= const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil))
   shostak))
 (good_mem_stack_push_TCC1 0
  (good_mem_stack_push_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack_push subtype
    "pegtopdown.push(pegtopdown.pos, pegtopdown.n)"
    "(pegtopdown.good_push_entry?(pegtopdown.len))")))
 (good_mem_stack_push_TCC2 0
  (good_mem_stack_push_TCC2-1 nil 3809020225
   ("" (skeep*)
    (("" (use exp2_lt :subst (n 41 m 64)) (("" (grind) nil nil)) nil))
    nil)
   ((exp2_lt formula-decl nil exp2 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack_push subtype
    "(number_fields.+)(pegtopdown.depth, 1)" "uint64")))
 (good_mem_stack_push_TCC3 0
  (good_mem_stack_push_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_mem_stack_push subtype "pegtopdown.stack"
    "(pegtopdown.nice_entry?(pegtopdown.len, pegtopdown.pos))")))
 (good_mem_stack_push 0
  (good_mem_stack_push-1 nil 3809141433
   ("" (skeep*)
    (("" (expand good_stack? +)
      (("" (ground)
        (("1" (grind) nil nil)
         ("2"
          (use good_mem_stack :subst (len len entry "push(pos!1, n)"))
          (("1" (ground)
            (("1" (grind) nil nil)
             ("2" (use mem_stack_push) (("2" (ground) nil nil)) nil)
             ("3" (grind) nil nil))
            nil)
           ("2" (typepred stack) (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((good_stack? def-decl "bool" pegtopdown nil)
    (good_mem_stack formula-decl nil pegtopdown nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil) (< const-decl "bool" reals nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (push adt-constructor-decl "[[uint32, uint8] -> (push?)]"
          pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (stack skolem-const-decl "(good_push_entry?(len))" pegtopdown nil)
    (pos!1 skolem-const-decl "upto(len)" pegtopdown nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (mem_stack_push formula-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (fine_stack?_TCC1 0
  (fine_stack?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (uint64 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype "pegtopdown.stack"
    "(pegtopdown.fine_push_entry?(pegtopdown.len))")))
 (fine_stack?_TCC2 0
  (fine_stack?_TCC2-1 nil 3809020225
   ("" (skeep*) (("" (typepred stack) (("" (grind) nil nil)) nil)) nil)
   ((good_stack? def-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint64 type-eq-decl nil integertypes nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype "pegtopdown.rest"
    "(pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A))")))
 (fine_stack?_TCC3 0
  (fine_stack?_TCC3-1 nil 3809020225
   ("" (skeep*)
    (("" (ground) (("" (typepred stack) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype "(number_fields.-)(pegtopdown.depth, 1)"
    "uint64")))
 (fine_stack?_TCC4 0
  (fine_stack?_TCC4-1 nil 3809020225
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred "stack") (("1" (grind) nil nil)) nil)
       ("2" (typepred "stack") (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? subtype
    "pegtopdown.A(pegtopdown.pos(pegtopdown.stack))(pegtopdown.nt(pegtopdown.stack))"
    "(pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A))")))
 (fine_stack?_TCC5 0
  (fine_stack?_TCC5-1 nil 3809020225 ("" (termination-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_stack? termination
    "pegtopdown.fine_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.A)"
    "nil")))
 (fine_mem_stack_TCC1 0
  (fine_mem_stack_TCC1-1 nil 3809020225
   ("" (skeep*) (("" (rewrite good_mem_stack) nil nil)) nil)
   ((good_mem_stack formula-decl nil pegtopdown nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint64 type-eq-decl nil integertypes nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_mem_stack subtype "pegtopdown.stack"
    "(pegtopdown.good_stack?(pegtopdown.len, pegtopdown.G, pegtopdown.depth, pegtopdown.A WITH [(pegtopdown.pos(pegtopdown.entry))(pegtopdown.nt(pegtopdown.entry)) := pegtopdown.u]))")))
 (fine_mem_stack 0
  (fine_mem_stack-1 nil 3809141465
   ("" (induct "depth")
    (("1" (skeep*)
      (("1" (expand fine_stack?)
        (("1" (expand good_stack? -) (("1" (ground) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep*)
      (("2" (expand fine_stack? +)
        (("2" (expand good_stack? -3)
          (("2" (ground)
            (("1" (rewrite mem_mem_stack)
              (("1" (expand mem_stack? 2)
                (("1" (ground)
                  (("1" (lift-if +)
                    (("1" (ground)
                      (("1" (lift-if +)
                        (("1" (ground)
                          (("1" (extensionality "(push?)")
                            (("1" (forward-chain -)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (inst?)
                            (("2" (ground)
                              (("2"
                                (replace -1)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -5 4)
                (("2" (lift-if +)
                  (("2" (ground)
                    (("2" (ground)
                      (("2" (expand mem_stack? +)
                        (("2" (ground)
                          (("2" (extensionality "(push?)")
                            (("2" (forward-chain -)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide -5 4) (("3" (grind) nil nil)) nil)
               ("4" (hide -6 3)
                (("4" (grind)
                  (("4" (extensionality "(push?)")
                    (("4" (inst?) (("4" (ground) nil nil)) nil)) nil))
                  nil))
                nil)
               ("5" (hide -5 4)
                (("5" (grind)
                  (("1" (extensionality "(push?)")
                    (("1" (inst?) (("1" (ground) nil nil)) nil)) nil)
                   ("2" (extensionality "(push?)")
                    (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)
                   ("3" (extensionality "(push?)")
                    (("3" (inst?) (("3" (ground) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite mem_mem_stack)
              (("1" (expand mem_stack? 2)
                (("1" (ground)
                  (("1" (lift-if +)
                    (("1" (ground)
                      (("1" (lift-if +)
                        (("1" (ground)
                          (("1" (extensionality "(push?)")
                            (("1" (forward-chain -)
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (inst?)
                            (("2" (ground)
                              (("2"
                                (replace -1)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -5 4)
                (("2" (hide -1)
                  (("2" (grind)
                    (("2" (extensionality "(push?)")
                      (("2" (inst?) (("2" (ground) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (hide -5 4)
                (("3" (hide -1) (("3" (grind) nil nil)) nil)) nil)
               ("4" (hide -6 3)
                (("4" (hide -2)
                  (("4" (grind)
                    (("4" (extensionality "(push?)")
                      (("4" (inst?) (("4" (ground) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("5" (hide -5 4)
                (("5" (hide -1)
                  (("5" (grind)
                    (("1" (hide -5 4)
                      (("1" (hide -1)
                        (("1" (grind)
                          (("1" (extensionality "(push?)")
                            (("1" (inst?) (("1" (ground) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (extensionality "(push?)")
                      (("2" (inst?) (("2" (ground) nil nil)) nil)) nil)
                     ("3" (extensionality "(push?)")
                      (("3" (inst?) (("3" (ground) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (grind) nil nil)) nil)
     ("4" (hide 2) (("4" (grind) nil nil)) nil)
     ("5" (hide 2) (("5" (grind) nil nil)) nil)
     ("6" (hide 2)
      (("6" (skeep*)
        (("6" (use good_mem_stack) (("6" (ground) nil nil)) nil)) nil))
      nil)
     ("7" (grind) nil nil) ("8" (hide 2) (("8" (grind) nil nil)) nil)
     ("9" (hide 2) (("9" (grind) nil nil)) nil)
     ("10" (hide 2) (("10" (grind) nil nil)) nil)
     ("11" (hide 2) (("11" (grind) nil nil)) nil)
     ("12" (hide 2) (("12" (grind) nil nil)) nil))
    nil)
   ((good_mem_stack formula-decl nil pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (mem_mem_stack formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ent_push_extensionality formula-decl nil pegtopdown nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (upto_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (<= const-decl "bool" reals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil))
   shostak))
 (loop_ready?_TCC1 0
  (loop_ready?_TCC1-1 nil 3809020225
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (loop_ready? subtype
    "(number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1)))"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_fail?_TCC1 0
  (good_fail?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_fail? subtype "pegtopdown.i" "below[length(s)]")))
 (good_fail?_TCC2 0
  (good_fail?_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_fail? subtype "pegtopdown.i" "below[length(s)]")))
 (good_fail?_TCC3 0
  (good_fail?_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC4 0
  (good_fail?_TCC4-1 nil 3809020225
   ("" (grind)
    (("" (typepred "A!1(i!1)(n1!1)") (("" (grind) nil nil)) nil)) nil)
   ((ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype
    "(number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1)))"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_fail?_TCC5 0
  (good_fail?_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC6 0
  (good_fail?_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype
    "pegtopdown.A((number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1))))(pegtopdown.n2)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC7 0
  (good_fail?_TCC7-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC8 0
  (good_fail?_TCC8-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n2)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC9 0
  (good_fail?_TCC9-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_fail?_TCC10 0
  (good_fail?_TCC10-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_fail? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_loop?_TCC1 0
  (good_loop?_TCC1-1 nil 3809020225
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_loop? subtype
    "(number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1)))"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_good?_TCC1 0
  (good_good?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (good_good? subtype
    "(number_fields.-)(pegtopdown.len, pegtopdown.i)" "nat")))
 (good_good?_TCC2 0
  (good_good?_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_good? subtype "pegtopdown.i" "below[length(s)]")))
 (good_good?_TCC3 0
  (good_good?_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (good_good? subtype "pegtopdown.i" "below[length(s)]")))
 (good_good?_TCC4 0
  (good_good?_TCC4-1 nil 3809020225
   ("" (skeep* :preds? t)
    (("" (typepred "A(i)(n1)") (("" (grind) nil nil)) nil)) nil)
   ((scaffold type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype
    "(number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1)))"
    "naturalnumbers.upto(pegtopdown.len)")))
 (good_good?_TCC5 0
  (good_good?_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC6 0
  (good_good?_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype
    "pegtopdown.A((number_fields.+)(pegtopdown.i, pegtopdown.span(pegtopdown.A(pegtopdown.i)(pegtopdown.n1))))(pegtopdown.n2)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC7 0
  (good_good?_TCC7-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC8 0
  (good_good?_TCC8-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC9 0
  (good_good?_TCC9-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n2)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC10 0
  (good_good?_TCC10-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good?_TCC11 0
  (good_good?_TCC11-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_good? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n1)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (fine_entry?_TCC1 0
  (fine_entry?_TCC1-1 nil 3809033166 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (fine_entry? subtype "pegtopdown.u" "(pegtopdown.push?)")))
 (fine_entry?_TCC2 0
  (fine_entry?_TCC2-1 nil 3809033166 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_entry? subtype "pegtopdown.nt(pegtopdown.u)" "non_terminal")))
 (fine_entry?_TCC3 0
  (fine_entry?_TCC3-1 nil 3809033166 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (fine_entry? subtype "pegtopdown.pos(pegtopdown.u)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (finer_entry?_TCC1 0
  (finer_entry?_TCC1-1 nil 3809058906 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (finer_entry? subtype "pegtopdown.nt(pegtopdown.u)"
    "non_terminal")))
 (finer_entry?_TCC2 0
  (finer_entry?_TCC2-1 nil 3809058906 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (finer_entry? subtype "pegtopdown.pos(pegtopdown.u)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (finer_entry?_TCC3 0
  (finer_entry?_TCC3-1 nil 3809063700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (finer_entry? subtype "pegtopdown.u"
    "(pegtopdown.good_push_entry?(pegtopdown.len))")))
 (good_tscaffold?_TCC1 0
  (good_tscaffold?_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (good_tscaffold? subtype "pegtopdown.A(pegtopdown.i)(pegtopdown.n)"
    "{x: pegtopdown.ent | booleans.OR(pegtopdown.fail?(x), pegtopdown.good?(x))}")))
 (good_good_tscaffold 0
  (good_good_tscaffold-1 nil 3809051076
   ("" (skeep*)
    (("" (expand "good_tscaffold?")
      (("" (skeep*)
        (("" (inst - i n)
          (("" (expand good_entry?)
            (("" (lift-if + :updates? nil)
              (("" (ground)
                (("1" (case "i = pos!1" "n = nt!1")
                  (("1" (assert) (("1" (grind) nil nil)) nil)
                   ("2" (assert)
                    (("2" (expand "good_fail?")
                      (("2" (lift-if)
                        (("2" (ground)
                          (("1" (grind) nil nil)
                           ("2" (hide -11)
                            (("2" (grind :exclude gfcount) nil nil))
                            nil)
                           ("3" (hide -11)
                            (("3" (grind :exclude gfcount) nil nil))
                            nil)
                           ("4" (hide -10)
                            (("4" (grind :exclude (max gfcount)) nil
                              nil))
                            nil)
                           ("5" (hide -10)
                            (("5" (grind :exclude (max gfcount)) nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (hide -6)
                    (("3" (grind :exclude (max gfcount)) nil nil))
                    nil))
                  nil)
                 ("2" (hide -5)
                  (("2" (expand "gfcount" +)
                    (("2" (rewrite "scafcount_update")
                      (("2" (hide -6)
                        (("2" (reveal -3)
                          (("2"
                            (lazy-grind :if-match all :exclude
                             scafcount)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (inst? -)
                  (("3" (grind :exclude gfcount) nil nil)) nil)
                 ("4" (hide -7)
                  (("4" (reveal -2)
                    (("4" (lazy-grind :if-match all :exclude scafcount)
                      nil nil))
                    nil))
                  nil)
                 ("5" (typepred u)
                  (("5" (hide -5 -7)
                    (("5" (typepred "A(i)(n)")
                      (("5" (grind :exclude gfcount) nil nil)) nil))
                    nil))
                  nil)
                 ("6" (hide -6)
                  (("6" (hide -2)
                    (("6" (lift-if)
                      (("6" (ground)
                        (("1" (grind) nil nil) ("2" (grind) nil nil)
                         ("3" (lift-if)
                          (("3" (ground)
                            (("1" (expand good_good?)
                              (("1"
                                (lift-if)
                                (("1"
                                  (ground)
                                  (("1"
                                    (ground)
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (grind :exclude max)
                                      nil
                                      nil))
                                    nil)
                                   ("2" (grind :exclude max) nil nil)
                                   ("3" (grind :exclude max) nil nil)
                                   ("4" (grind :exclude max) nil nil)
                                   ("5" (grind :exclude max) nil nil)
                                   ("6" (grind) nil nil)
                                   ("7" (grind) nil nil)
                                   ("8" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind :exclude (max gfcount)) nil
                              nil))
                            nil))
                          nil)
                         ("4" (grind :exclude max) nil nil)
                         ("5" (grind :exclude max) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("7" (hide -5 -7)
                  (("7" (typepred "A(i)(n)")
                    (("7" (expand "gfcount" +)
                      (("7" (rewrite scafcount_update)
                        (("7" (reveal -3)
                          (("7"
                            (lazy-grind :if-match all :exclude
                             scafcount)
                            nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("8" (hide -4 -6)
                  (("8" (reveal -3)
                    (("8" (lazy-grind :if-match all :exclude scafcount)
                      nil nil))
                    nil))
                  nil)
                 ("9" (hide -5) (("9" (grind :exclude max) nil nil))
                  nil)
                 ("10" (hide -6)
                  (("10" (expand gfcount)
                    (("10" (reveal -2)
                      (("10" (hide -5)
                        (("10" (rewrite "scafcount_update")
                          (("10" (lift-if)
                            (("10" (ground)
                              (("10"
                                (lift-if)
                                (("10"
                                  (ground)
                                  (("10"
                                    (expand fine_entry?)
                                    (("10"
                                      (expand "good_fail?")
                                      (("10"
                                        (lift-if)
                                        (("10"
                                          (ground)
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (grind
                                               :exclude
                                               scafcount)
                                              nil
                                              nil))
                                            nil)
                                           ("2"
                                            (inst? :copy? t)
                                            (("2"
                                              (inst
                                               -
                                               "span(A(pos!1)(e1(G(nt!1)))) + pos!1"
                                               "e2(G(nt!1))")
                                              (("2"
                                                (grind
                                                 :exclude
                                                 scafcount)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (inst? :copy? t)
                                            (("3"
                                              (inst
                                               -
                                               "pos!1"
                                               "e2(G(nt!1))")
                                              (("3"
                                                (grind
                                                 :exclude
                                                 scafcount)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (inst?)
                                            (("4"
                                              (grind
                                               :exclude
                                               scafcount)
                                              nil
                                              nil))
                                            nil)
                                           ("5"
                                            (inst?)
                                            (("5" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("11" (inst?)
                  (("11" (grind :exclude (max gfcount)) nil nil)) nil)
                 ("12" (hide -4 -6)
                  (("12" (expand gfcount)
                    (("12" (rewrite scafcount_update)
                      (("12" (reveal -3)
                        (("12"
                          (lazy-grind :if-match all :exclude
                           (max scafcount))
                          nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("13" (typepred "A(i)(n)")
                  (("13" (typepred "u")
                    (("13" (hide -5 -7)
                      (("13" (grind :exclude (max gfcount)) nil nil))
                      nil))
                    nil))
                  nil)
                 ("14" (hide -5)
                  (("14" (typepred "A(i)(n)")
                    (("14" (typepred "u")
                      (("14" (grind :exclude (max gfcount)) nil nil))
                      nil))
                    nil))
                  nil)
                 ("15" (hide -6)
                  (("15" (reveal -2)
                    (("15" (expand gfcount)
                      (("15" (rewrite scafcount_update)
                        (("15" (lift-if)
                          (("15" (ground)
                            (("1" (lift-if)
                              (("1"
                                (ground)
                                (("1"
                                  (hide -15)
                                  (("1"
                                    (grind :exclude (max scafcount))
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (lift-if)
                              (("2"
                                (ground)
                                (("2"
                                  (hide -15)
                                  (("2"
                                    (grind :exclude (max scafcount))
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (lift-if)
                              (("3"
                                (ground)
                                (("3"
                                  (hide -16)
                                  (("3"
                                    (grind :exclude (max scafcount))
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("4" (lift-if)
                              (("4"
                                (ground)
                                (("4"
                                  (expand fine_entry?)
                                  (("4"
                                    (ground)
                                    (("4"
                                      (expand "good_good?")
                                      (("4"
                                        (lift-if)
                                        (("4"
                                          (ground)
                                          (("1"
                                            (inst? :copy? t)
                                            (("1"
                                              (inst
                                               -
                                               "span(A(pos!1)(e1(G(nt!1)))) + pos!1"
                                               "e2(G(nt!1))")
                                              (("1"
                                                (grind
                                                 :exclude
                                                 scafcount)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (inst?)
                                            (("2"
                                              (grind
                                               :exclude
                                               scafcount)
                                              nil
                                              nil))
                                            nil)
                                           ("3"
                                            (inst? :copy? t)
                                            (("3"
                                              (inst
                                               -
                                               "pos!1"
                                               "e2(G(nt!1))")
                                              (("3"
                                                (grind
                                                 :exclude
                                                 scafcount)
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (inst?)
                                            (("4"
                                              (grind
                                               :exclude
                                               scafcount)
                                              nil
                                              nil))
                                            nil)
                                           ("5"
                                            (inst?)
                                            (("5"
                                              (grind
                                               :exclude
                                               scafcount)
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("16" (expand "gfcount" +)
                  (("16" (rewrite scafcount_update)
                    (("16" (hide -5)
                      (("16" (reveal -2)
                        (("16"
                          (lazy-grind :if-match all :exclude
                           (max scafcount))
                          nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((good_tscaffold? const-decl "bool" pegtopdown nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (scafcount_update formula-decl nil pegtopdown nil)
    (e shared-adt-accessor-decl
     "[{x: peg | and?(x) OR not?(x)} -> non_terminal]" pegtopdown nil)
    (not? adt-recognizer-decl "[peg -> boolean]" pegtopdown nil)
    (and? adt-recognizer-decl "[peg -> boolean]" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (good? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (span adt-accessor-decl "[(good?) -> uint32]" pegtopdown nil)
    (e2 shared-adt-accessor-decl
     "[{x: peg | concat?(x) OR or?(x)} -> non_terminal]" pegtopdown
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (sigma def-decl "real" sigma reals)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (e1 shared-adt-accessor-decl
     "[{x: peg | concat?(x) OR or?(x)} -> non_terminal]" pegtopdown
     nil)
    (or? adt-recognizer-decl "[peg -> boolean]" pegtopdown nil)
    (concat? adt-recognizer-decl "[peg -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (peg type-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   shostak))
 (state_TCC1 0
  (state_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (state subtype "pegtopdown.stack" "(pegtopdown.push?)")))
 (state_TCC2 0
  (state_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (state subtype "pegtopdown.pos(pegtopdown.stack)"
    "naturalnumbers.upto(pegtopdown.len)")))
 (state_TCC3 0
  (state_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (state subtype "pegtopdown.nt(pegtopdown.stack)" "non_terminal")))
 (ne_state_TCC1 0
  (ne_state_TCC1-1 nil 3809020225
   ("" (skeep*) (("" (typepred "st`stack") (("" (grind) nil nil)) nil))
    nil)
   ((state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (ne_state subtype "pegtopdown.st`stack" "(pegtopdown.push?)")))
 (newentry_TCC1 0
  (newentry_TCC1-1 nil 3809020225
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "pegtopdown.St`stack" "(pegtopdown.push?)")))
 (newentry_TCC2 0
  (newentry_TCC2-1 nil 3809027298
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.pos(pegtopdown.St`stack)"
             "naturalnumbers.upto(pegtopdown.len)")))
 (newentry_TCC3 0
  (newentry_TCC3-1 nil 3809027298
   ("" (skeep*)
    (("" (typepred "St`stack")
      (("" (typepred St) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.nt(pegtopdown.St`stack)"
             "non_terminal")))
 (newentry_TCC4 0
  (newentry_TCC2-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred St)
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (empty? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "pegtopdown.cur" "non_terminal")))
 (newentry_TCC5 0
  (newentry_TCC3-1 nil 3809020225
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.pos"
             "naturalnumbers.upto(pegtopdown.len)")))
 (newentry_TCC6 0
  (newentry_TCC4-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC7 0
  (newentry_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (newentry subtype "0" "uint32")))
 (newentry_TCC8 0
  (newentry_TCC6-1 nil 3809020225
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.good(0, 0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC9 0
  (newentry_TCC7-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC10 0
  (newentry_TCC8-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.fail(0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC11 0
  (newentry_TCC9-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`stack")
      (("" (typepred St) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "pegtopdown.pos" "below[length(s)]")))
 (newentry_TCC12 0
  (newentry_TCC10-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC13 0
  (newentry_TCC11-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.fail(0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC14 0
  (newentry_TCC12-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC15 0
  (newentry_TCC13-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "1" "uint32")))
 (newentry_TCC16 0
  (newentry_TCC14-1 nil 3809020225
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.good(0, 1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC17 0
  (newentry_TCC15-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred St)
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (empty? const-decl "bool" pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "pegtopdown.pos" "below[length(s)]")))
 (newentry_TCC18 0
  (newentry_TCC16-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC19 0
  (newentry_TCC17-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.fail(0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC20 0
  (newentry_TCC18-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "0" "uint64")))
 (newentry_TCC21 0
  (newentry_TCC19-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (newentry subtype "1" "uint32")))
 (newentry_TCC22 0
  (newentry_TCC20-1 nil 3809020225
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.good(0, 1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC23 0
  (newentry_TCC21-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC24 0
  (newentry_TCC22-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.fail((number_fields.+)(pegtopdown.d1, 1))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC25 0
  (newentry_TCC23-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)") (("" (grind) nil nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.pos, pegtopdown.sp)"
             "naturalnumbers.upto(pegtopdown.len)")))
 (newentry_TCC26 0
  (newentry_TCC24-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst-cp - pos!1 n1)
              (("" (inst - pos!1+sp n2)
                (("" (ground)
                  (("1" (expand gfcount)
                    (("1" (use "sigma_max")
                      (("1" (ground)
                        (("1"
                          (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                          (("1" (assert)
                            (("1"
                              (name-replace lnn
                               "len * num_non_terminals + num_non_terminals")
                              (("1"
                                (assert)
                                (("1"
                                  (expand max)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (ground)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2"
                              (case "len * num_non_terminals <= exp2(46)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (use
                                 "lt_times_lt_pos1"
                                 :subst
                                 (px
                                  len
                                  nnz
                                  num_non_terminals
                                  y
                                  "exp2(32)"
                                  w
                                  "exp2(8)"))
                                (("1"
                                  (hide-all-but (-1 1))
                                  (("1"
                                    (grind)
                                    (("1"
                                      (typepred len)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "(number_fields.+)(1, real_defs.max(pegtopdown.d1, pegtopdown.d2))"
             "uint64")))
 (newentry_TCC27 0
  (newentry_TCC25-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil))
   nil
   (newentry subtype
             "pegtopdown.fail((number_fields.+)(1, real_defs.max(pegtopdown.d1, pegtopdown.d2)))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC28 0
  (newentry_TCC26-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst-cp - pos!1 n1)
              (("" (inst - pos!1+sp n2)
                (("" (ground)
                  (("1" (expand gfcount)
                    (("1" (use "sigma_max")
                      (("1" (ground)
                        (("1"
                          (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                          (("1" (assert)
                            (("1"
                              (name-replace lnn
                               "len * num_non_terminals + num_non_terminals")
                              (("1"
                                (assert)
                                (("1"
                                  (expand max)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (ground)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2"
                              (case "len * num_non_terminals <= exp2(46)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (use
                                 "lt_times_lt_pos1"
                                 :subst
                                 (px
                                  len
                                  nnz
                                  num_non_terminals
                                  y
                                  "exp2(32)"
                                  w
                                  "exp2(8)"))
                                (("1"
                                  (hide-all-but (-1 1))
                                  (("1"
                                    (grind)
                                    (("1"
                                      (typepred len)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "(number_fields.+)(1, real_defs.max(pegtopdown.d1, pegtopdown.d2))"
             "uint64")))
 (newentry_TCC29 0
  (newentry_TCC27-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1 + sp)(n2)")
        (("" (typepred len) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.sp, pegtopdown.sp2)"
             "uint32")))
 (newentry_TCC30 0
  (newentry_TCC28-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1 + sp)(n2)") (("" (grind) nil nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.good((number_fields.+)(1, real_defs.max(pegtopdown.d1, pegtopdown.d2)), (number_fields.+)(pegtopdown.sp, pegtopdown.sp2))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC31 0
  (newentry_TCC29-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1 + sp)(n2)")
        (("" (typepred len) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.pos, pegtopdown.sp)"
             "uint32")))
 (newentry_TCC32 0
  (newentry_TCC30-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1 + sp)(n2)")
        (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.push((number_fields.+)(pegtopdown.pos, pegtopdown.sp), pegtopdown.n2)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC33 0
  (newentry_TCC33-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC34 0
  (newentry_TCC32-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.push(pegtopdown.pos, pegtopdown.n1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC35 0
  (newentry_TCC31-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC36 0
  (newentry_TCC34-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst-cp - pos!1 n1)
              (("" (inst - pos!1 n2)
                (("" (ground)
                  (("1" (expand gfcount)
                    (("1" (use "sigma_max")
                      (("1" (ground)
                        (("1"
                          (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                          (("1" (assert)
                            (("1"
                              (name-replace lnn
                               "len * num_non_terminals + num_non_terminals")
                              (("1"
                                (assert)
                                (("1"
                                  (expand max)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (ground)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2"
                              (case "len * num_non_terminals <= exp2(46)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (use
                                 "lt_times_lt_pos1"
                                 :subst
                                 (px
                                  len
                                  nnz
                                  num_non_terminals
                                  y
                                  "exp2(32)"
                                  w
                                  "exp2(8)"))
                                (("1"
                                  (hide-all-but (-1 1))
                                  (("1"
                                    (grind)
                                    (("1"
                                      (typepred len)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "(number_fields.+)(real_defs.max(pegtopdown.d1, pegtopdown.d2), 1)"
             "uint64")))
 (newentry_TCC37 0
  (newentry_TCC35-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil))
   nil
   (newentry subtype
             "pegtopdown.fail((number_fields.+)(real_defs.max(pegtopdown.d1, pegtopdown.d2), 1))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC38 0
  (newentry_TCC36-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst-cp - pos!1 n1)
              (("" (inst - pos!1 n2)
                (("" (ground)
                  (("1" (expand gfcount)
                    (("1" (use "sigma_max")
                      (("1" (ground)
                        (("1"
                          (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                          (("1" (assert)
                            (("1"
                              (name-replace lnn
                               "len * num_non_terminals + num_non_terminals")
                              (("1"
                                (assert)
                                (("1"
                                  (expand max)
                                  (("1"
                                    (lift-if)
                                    (("1"
                                      (ground)
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2"
                              (case "len * num_non_terminals <= exp2(46)")
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (use
                                 "lt_times_lt_pos1"
                                 :subst
                                 (px
                                  len
                                  nnz
                                  num_non_terminals
                                  y
                                  "exp2(32)"
                                  w
                                  "exp2(8)"))
                                (("1"
                                  (hide-all-but (-1 1))
                                  (("1"
                                    (grind)
                                    (("1"
                                      (typepred len)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil) ("3" (grind) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "(number_fields.+)(real_defs.max(pegtopdown.d1, pegtopdown.d2), 1)"
             "uint64")))
 (newentry_TCC39 0
  (newentry_TCC37-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1)(n2)")
        (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.good((number_fields.+)(real_defs.max(pegtopdown.d1, pegtopdown.d2), 1), pegtopdown.sp)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC40 0
  (newentry_TCC38-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`scaf(pos!1)(n2)")
        (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.push(pegtopdown.pos, pegtopdown.n2)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC41 0
  (newentry_TCC39-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC42 0
  (newentry_TCC40-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC43 0
  (newentry_TCC41-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.good((number_fields.+)(pegtopdown.d1, 1), pegtopdown.sp)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC44 0
  (newentry_TCC42-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.push(pegtopdown.pos, pegtopdown.n1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC45 0
  (newentry_TCC43-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC46 0
  (newentry_TCC44-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC47 0
  (newentry_TCC45-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.fail((number_fields.+)(pegtopdown.d1, 1))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC48 0
  (newentry_TCC46-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC49 0
  (newentry_TCC47-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (newentry subtype "0" "uint32")))
 (newentry_TCC50 0
  (newentry_TCC48-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.good((number_fields.+)(pegtopdown.d1, 1), 0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC51 0
  (newentry_TCC49-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.push(pegtopdown.pos, pegtopdown.n1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC52 0
  (newentry_TCC50-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC53 0
  (newentry_TCC51-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC54 0
  (newentry_TCC52-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (newentry subtype "0" "uint32")))
 (newentry_TCC55 0
  (newentry_TCC53-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.good((number_fields.+)(pegtopdown.d1, 1), 0)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC56 0
  (newentry_TCC54-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("" (expand "good_tscaffold?")
            (("" (inst - pos!1 n1)
              (("" (ground)
                (("1" (expand gfcount)
                  (("1" (use "sigma_max")
                    (("1" (ground)
                      (("1"
                        (case "len * num_non_terminals + num_non_terminals < exp2(64) - 2")
                        (("1" (assert)
                          (("1"
                            (name-replace lnn
                             "len * num_non_terminals + num_non_terminals")
                            (("1" (assert) (("1" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2"
                            (case "len * num_non_terminals <= exp2(46)")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2"
                              (use "lt_times_lt_pos1" :subst
                                   (px
                                    len
                                    nnz
                                    num_non_terminals
                                    y
                                    "exp2(32)"
                                    w
                                    "exp2(8)"))
                              (("1"
                                (hide-all-but (-1 1))
                                (("1"
                                  (grind)
                                  (("1"
                                    (typepred len)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "(number_fields.+)(pegtopdown.d1, 1)" "uint64")))
 (newentry_TCC57 0
  (newentry_TCC55-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype
             "pegtopdown.fail((number_fields.+)(pegtopdown.d1, 1))"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC58 0
  (newentry_TCC56-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "St`scaf(pos!1)(n1)")
      (("" (typepred "St`stack") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((ne_state type-eq-decl nil pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.push(pegtopdown.pos, pegtopdown.n1)"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (newentry_TCC59 0
  (newentry_TCC57-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (newentry subtype "pegtopdown.loop"
             "pegtopdown.finer_entry(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.St`scaf, pegtopdown.St`stack, pegtopdown.pos(pegtopdown.St`stack), pegtopdown.nt(pegtopdown.St`stack))")))
 (step_TCC1 0
  (step_TCC1-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "pegtopdown.stack" "(pegtopdown.push?)")))
 (step_TCC2 0
  (step_TCC2-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "pegtopdown.cur" "non_terminal")))
 (step_TCC3 0
  (step_TCC3-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.pos"
         "naturalnumbers.upto(pegtopdown.len)")))
 (step_TCC4 0
  (step_TCC4-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.St"
         "pegtopdown.ne_state(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.start, pegtopdown.rootnt)")))
 (step_TCC5 0
  (step_TCC5-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.p"
         "naturalnumbers.upto(pegtopdown.len)")))
 (step_TCC6 0
  (step_TCC6-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (step subtype "pegtopdown.n" "non_terminal")))
 (step_TCC7 0
  (step_TCC7-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.stack"
         "(pegtopdown.nice_entry?(pegtopdown.len, pegtopdown.p))")))
 (step_TCC8 0
  (step_TCC8-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("1" (hide -2)
            (("1" (typepred stack) (("1" (grind) nil nil)) nil)) nil)
           ("2" (use good_good_tscaffold)
            (("1" (ground)
              (("1" (typepred stack)
                (("1" (typepred newentry!1) (("1" (grind) nil nil))
                  nil))
                nil)
               ("2" (typepred stack)
                (("2" (hide 2)
                  (("2" (expand fine_entry?) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (typepred lflag)
                    (("3" (case lflag)
                      (("1" (assert)
                        (("1" (hide -3) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (assert) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred stack) (("2" (grind) nil nil)) nil)
             ("3" (typepred newentry!1) (("3" (grind) nil nil)) nil)
             ("4" (typepred newentry!1) (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (sigma def-decl "real" sigma reals)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (p!1 skolem-const-decl "uint32" pegtopdown nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (n skolem-const-decl "uint8" pegtopdown nil)
    (stack skolem-const-decl "(fine_stack?(len, G, St`depth, St`scaf))"
     pegtopdown nil)
    (St skolem-const-decl "state(len, G, s, start, rootnt)" pegtopdown
     nil)
    (rootnt skolem-const-decl "non_terminal" pegtopdown nil)
    (start skolem-const-decl "upto(len)" pegtopdown nil)
    (s skolem-const-decl "strings(len)" pegtopdown nil)
    (G skolem-const-decl "lang_spec" pegtopdown nil)
    (good_good_tscaffold formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "pegtopdown.St`scaf WITH [(pegtopdown.p)(pegtopdown.n) := pegtopdown.stack]"
         "(pegtopdown.fine_scaffold?(pegtopdown.len, pegtopdown.G, pegtopdown.s)(pegtopdown.start, pegtopdown.rootnt))")))
 (step_TCC9 0
  (step_TCC9-1 nil 3809020225
   ("" (skeep*)
    (("" (split)
      (("1" (typepred stack)
        (("1" (typepred depth)
          (("1" (expand good_depth?)
            (("1" (expand pushcount)
              (("1" (use scafcount_max)
                (("1" (assert)
                  (("1" (use exp2_lt :subst (n 41 m 64))
                    (("1" (ground) (("1" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "good_depth?")
        (("2" (expand pushcount)
          (("2" (rewrite scafcount_update)
            (("1" (lift-if)
              (("1" (ground)
                (("1" (typepred newentry!1) (("1" (grind) nil nil))
                  nil)
                 ("2" (typepred newentry!1)
                  (("2" (typepred newentry!1) (("2" (grind) nil nil))
                    nil))
                  nil)
                 ("3" (typepred depth)
                  (("3" (grind :exclude scafcount) nil nil)) nil)
                 ("4" (typepred newentry!1) (("4" (grind) nil nil))
                  nil)
                 ("5" (typepred stack) (("5" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (typepred stack) (("2" (grind) nil nil)) nil)
             ("3" (typepred newentry!1) (("3" (grind) nil nil)) nil)
             ("4" (typepred newentry!1) (("4" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pushcount const-decl "uint64" pegtopdown nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (count const-decl "upto(len)" arrayCount nil)
    (sigma def-decl "real" sigma reals)
    (scafcount const-decl "uint64" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (exp2_lt formula-decl nil exp2 nil)
    (scafcount_max formula-decl nil pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (strings type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (scafcount_update formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.+)(pegtopdown.depth, 1)"
         "(pegtopdown.good_depth?(pegtopdown.len, pegtopdown.St`scaf WITH [(pegtopdown.p)(pegtopdown.n) := pegtopdown.stack]))")))
 (step_TCC10 0
  (step_TCC10-1 nil 3809020225
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred stack)
        (("1" (typepred newentry!1) (("1" (grind) nil nil)) nil)) nil)
       ("2" (typepred stack)
        (("2" (expand "good_stack?" +)
          (("2" (ground)
            (("1" (typepred newentry!1) (("1" (grind) nil nil)) nil)
             ("2" (lemma good_mem_stack)
              (("2"
                (inst - G "depth" len scaf "push(p!1, n)" "stack"
                 stack)
                (("1" (ground)
                  (("1" (grind) nil nil)
                   ("2" (typepred newentry!1) (("2" (grind) nil nil))
                    nil)
                   ("3" (grind) nil nil)
                   ("4" (typepred newentry!1) (("4" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (typepred newentry!1) (("3" (grind) nil nil))
                  nil))
                nil))
              nil)
             ("3" (typepred newentry!1)
              (("3" (expand finer_entry?)
                (("3" (ground)
                  (("3" (grind :defs nil :rewrites successor) nil nil))
                  nil))
                nil))
              nil)
             ("4" (lemma good_mem_stack)
              (("4"
                (inst - G "depth" len scaf "push(p!1, n)" "stack"
                 stack)
                (("1" (ground)
                  (("1" (grind) nil nil)
                   ("2" (typepred newentry!1) (("2" (grind) nil nil))
                    nil)
                   ("3" (forward-chain mem_stack_push)
                    (("1" (ground)
                      (("1" (typepred newentry!1)
                        (("1"
                          (grind :defs nil :rewrites
                           (finer_entry? fine_entry?))
                          nil nil))
                        nil))
                      nil)
                     ("2" (typepred newentry!1) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("4" (typepred newentry!1) (("4" (grind) nil nil))
                    nil))
                  nil)
                 ("2" (grind) nil nil)
                 ("3" (typepred newentry!1) (("3" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (expand fine_stack? +)
        (("3" (ground)
          (("1" (lemma mem_mem_stack)
            (("1" (inst - G depth len scaf _ _ _ _)
              (("1" (inst - "push(p!1, n)" "push(p!1, n)" stack stack)
                (("1" (ground)
                  (("1" (assert)
                    (("1" (replace -11)
                      (("1" (assert)
                        (("1" (replace -3)
                          (("1" (replace -1 :hide? t)
                            (("1" (use mem_stack_push)
                              (("1"
                                (ground)
                                (("1"
                                  (typepred newentry!1)
                                  (("1"
                                    (hide -3)
                                    (("1"
                                      (expand finer_entry?)
                                      (("1"
                                        (ground)
                                        (("1"
                                          (replace -13)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide -1)
                    (("2" (typepred newentry!1) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("3" (hide -1)
                    (("3" (typepred newentry!1) (("3" (grind) nil nil))
                      nil))
                    nil)
                   ("4" (hide -2)
                    (("4" (use mem_stack_push)
                      (("4" (ground)
                        (("4" (hide -2)
                          (("4" (typepred newentry!1)
                            (("4" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("5" (hide -1)
                    (("5" (typepred newentry!1) (("5" (grind) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide -1)
                  (("2" (typepred stack) (("2" (grind) nil nil)) nil))
                  nil)
                 ("3" (hide -1)
                  (("3" (typepred newentry!1) (("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred stack)
            (("2"
              (use fine_mem_stack :subst
                   (len len entry "push(p!1, n)" u stack stack stack))
              (("1" (ground)
                (("1" (typepred stack) (("1" (grind) nil nil)) nil)
                 ("2" (typepred newentry!1) (("2" (grind) nil nil))
                  nil)
                 ("3" (use mem_stack_push)
                  (("3" (ground)
                    (("3" (hide -2)
                      (("3" (typepred newentry!1)
                        (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("4" (typepred newentry!1) (("4" (grind) nil nil))
                  nil))
                nil)
               ("2" (typepred newentry!1) (("2" (grind) nil nil)) nil)
               ("3" (typepred newentry!1) (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (strings type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (mem_stack_push formula-decl nil pegtopdown nil)
    (good_mem_stack formula-decl nil pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (G skolem-const-decl "lang_spec" pegtopdown nil)
    (s skolem-const-decl "strings(len)" pegtopdown nil)
    (start skolem-const-decl "upto(len)" pegtopdown nil)
    (rootnt skolem-const-decl "non_terminal" pegtopdown nil)
    (St skolem-const-decl "state(len, G, s, start, rootnt)" pegtopdown
     nil)
    (stack skolem-const-decl "(fine_stack?(len, G, St`depth, St`scaf))"
     pegtopdown nil)
    (n skolem-const-decl "uint8" pegtopdown nil)
    (p!1 skolem-const-decl "uint32" pegtopdown nil)
    (push adt-constructor-decl "[[uint32, uint8] -> (push?)]"
          pegtopdown nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (empty? const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (mem_mem_stack formula-decl nil pegtopdown nil)
    (fine_mem_stack formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.newentry"
         "(pegtopdown.fine_stack?(pegtopdown.len, pegtopdown.G, (number_fields.+)(pegtopdown.depth, 1), pegtopdown.St`scaf WITH [(pegtopdown.p)(pegtopdown.n) := pegtopdown.stack]))")))
 (step_TCC11 0
  (step_TCC11-1 nil 3809020225
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred lflag)
        (("1" (assert)
          (("1" (hide -2)
            (("1" (ground)
              (("1" (typepred stack) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (typepred lflag)
        (("2" (assert)
          (("2" (hide -1)
            (("2" (skeep*)
              (("2" (lift-if)
                (("2" (ground)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (typepred stack) (("1" (grind) nil nil))
                        nil)
                       ("2" (inst?) nil nil))
                      nil))
                    nil)
                   ("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((empty? const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ent type-decl nil pegtopdown nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.St`lflag"
         "{b: booleans.bool | IF b THEN booleans.OR(pegtopdown.nt(pegtopdown.newentry) = pegtopdown.num_non_terminals, pegtopdown.loop_ready?(pegtopdown.len, pegtopdown.G, pegtopdown.St`scaf WITH [(pegtopdown.p)(pegtopdown.n) := pegtopdown.stack], pegtopdown.pos(pegtopdown.newentry), pegtopdown.nt(pegtopdown.newentry))) ELSE FORALL (i: naturalnumbers.upto(pegtopdown.len)), (n_1: pegtopdown.non_terminal): (booleans.NOT)(pegtopdown.loop?(pegtopdown.St`scaf WITH [(pegtopdown.p)(pegtopdown.n) := pegtopdown.stack](i)(n_1))) ENDIF}")))
 (step_TCC12 0
  (step_TCC12-1 nil 3809020225 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.newentry"
         "(pegtopdown.nice_entry?(pegtopdown.len, pegtopdown.pos))")))
 (step_TCC13 0
  (step_TCC13-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred "scaf")
      (("" (expand "fine_scaffold?")
        (("" (ground)
          (("1" (hide -2)
            (("1" (typepred newentry!1)
              (("1" (expand good_root?)
                (("1" (expand finer_entry?)
                  (("1" (expand fine_entry?)
                    (("1" (grind :exclude (max gfcount)) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use good_good_tscaffold)
            (("1" (ground)
              (("1" (typepred stack) (("1" (grind) nil nil)) nil)
               ("2" (typepred newentry!1)
                (("2" (grind :exclude fine_entry?) nil nil)) nil)
               ("3" (hide 2)
                (("3" (skeep*)
                  (("3" (typepred lflag)
                    (("3" (case lflag)
                      (("1" (assert)
                        (("1" (hide -3) (("1" (grind) nil nil)) nil))
                        nil)
                       ("2" (assert) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred newentry!1)
              (("2" (expand finer_entry?)
                (("2" (expand fine_entry?)
                  (("2" (hide -2 -3 2 -11) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (newentry!1 skolem-const-decl
     "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
     pegtopdown nil)
    (St skolem-const-decl "state(len, G, s, start, rootnt)" pegtopdown
     nil)
    (rootnt skolem-const-decl "non_terminal" pegtopdown nil)
    (start skolem-const-decl "upto(len)" pegtopdown nil)
    (s skolem-const-decl "strings(len)" pegtopdown nil)
    (G skolem-const-decl "lang_spec" pegtopdown nil)
    (pos!1 skolem-const-decl "uint32" pegtopdown nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (good_good_tscaffold formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype
         "pegtopdown.St`scaf WITH [(pegtopdown.pos)(pegtopdown.cur) := pegtopdown.newentry]"
         "(pegtopdown.fine_scaffold?(pegtopdown.len, pegtopdown.G, pegtopdown.s)(pegtopdown.start, pegtopdown.rootnt))")))
 (step_TCC14 0
  (step_TCC14-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred stack)
      (("" (typepred depth)
        (("" (expand good_depth?)
          (("" (expand pushcount)
            (("" (use scafcount_max)
              (("" (ground)
                (("1" (grind) nil nil)
                 ("2" (rewrite scafcount_update)
                  (("1" (lift-if)
                    (("1" (ground)
                      (("1" (grind) nil nil)
                       ("2" (grind :exclude scafcount) nil nil))
                      nil))
                    nil)
                   ("2" (typepred newentry!1)
                    (("2" (grind :exclude scafcount) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint64 type-eq-decl nil integertypes nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (scafcount_max formula-decl nil pegtopdown nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (scafcount_update formula-decl nil pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (successor const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "(number_fields.-)(pegtopdown.depth, 1)"
         "(pegtopdown.good_depth?(pegtopdown.len, pegtopdown.St`scaf WITH [(pegtopdown.pos)(pegtopdown.cur) := pegtopdown.newentry]))")))
 (step_TCC15 0
  (step_TCC15-1 nil 3809020225
   ("" (skeep*)
    (("" (ground)
      (("1" (typepred stack) (("1" (grind) nil nil)) nil)
       ("2" (typepred stack)
        (("2" (lemma good_mem_stack)
          (("2"
            (inst - G "depth - 1" len scaf "push(pos!1, cur)" "rest"
             newentry!1)
            (("1" (ground)
              (("1" (hide 2) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil)
               ("3" (hide 1)
                (("3" (expand "fine_stack?")
                  (("3" (ground)
                    (("1" (grind) nil nil)
                     ("2" (case-replace "push(pos!1, cur) = stack")
                      (("1" (assert) nil nil)
                       ("2" (apply-extensionality) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (grind) nil nil))
              nil)
             ("2" (typepred newentry!1) (("2" (grind) nil nil)) nil)
             ("3" (typepred newentry!1) (("3" (grind) nil nil)) nil)
             ("4" (grind) nil nil))
            nil))
          nil))
        nil)
       ("3"
        (use fine_mem_stack :subst
             (len len entry "push(pos!1, cur)" u newentry!1 stack
              rest))
        (("1" (ground)
          (("1" (hide 2)
            (("1" (typepred stack) (("1" (grind) nil nil)) nil)) nil)
           ("2" (typepred stack) (("2" (grind) nil nil)) nil)
           ("3" (hide 2)
            (("3" (typepred stack) (("3" (grind) nil nil)) nil)) nil)
           ("4" (typepred stack)
            (("4" (hide 1)
              (("4" (expand fine_stack?)
                (("4" (ground)
                  (("1" (grind) nil nil)
                   ("2" (case-replace "push(pos!1, cur) = stack")
                    (("1" (assert) nil nil)
                     ("2" (apply-extensionality) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (typepred stack) (("5" (grind) nil nil)) nil))
          nil)
         ("2" (typepred stack) (("2" (grind) nil nil)) nil)
         ("3" (typepred newentry!1) (("3" (grind) nil nil)) nil)
         ("4" (typepred stack) (("4" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (successor const-decl "bool" pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (ent type-decl nil pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (strings type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (good_mem_stack formula-decl nil pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (ent_push_extensionality formula-decl nil pegtopdown nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (newentry!1 skolem-const-decl
     "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
     pegtopdown nil)
    (cur skolem-const-decl "uint8" pegtopdown nil)
    (pos!1 skolem-const-decl "uint32" pegtopdown nil)
    (push adt-constructor-decl "[[uint32, uint8] -> (push?)]"
          pegtopdown nil)
    (len skolem-const-decl "uint32" pegtopdown nil)
    (G skolem-const-decl "lang_spec" pegtopdown nil)
    (s skolem-const-decl "strings(len)" pegtopdown nil)
    (start skolem-const-decl "upto(len)" pegtopdown nil)
    (rootnt skolem-const-decl "non_terminal" pegtopdown nil)
    (St skolem-const-decl "state(len, G, s, start, rootnt)" pegtopdown
     nil)
    (depth skolem-const-decl "(good_depth?(len, St`scaf))" pegtopdown
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (fine_mem_stack formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.rest"
         "(pegtopdown.fine_stack?(pegtopdown.len, pegtopdown.G, (number_fields.-)(pegtopdown.depth, 1), pegtopdown.St`scaf WITH [(pegtopdown.pos)(pegtopdown.cur) := pegtopdown.newentry]))")))
 (step_TCC16 0
  (step_TCC16-1 nil 3809020225
   ("" (skeep*)
    (("" (typepred stack)
      (("" (expand good_stack?)
        (("" (ground)
          (("1" (typepred newentry!1) (("1" (grind) nil nil)) nil)
           ("2" (grind :exclude (good_stack? fine_stack? mem_stack?))
            nil nil)
           ("3" (typepred newentry!1)
            (("3" (typepred lflag)
              (("3" (ground)
                (("1" (skeep*)
                  (("1" (inst - i n) (("1" (grind :defs nil) nil nil))
                    nil))
                  nil)
                 ("2" (hide 2) (("2" (grind) nil nil)) nil)
                 ("3" (skeep*)
                  (("3" (inst - i n) (("3" (grind :defs nil) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (hide -5 -7) (("4" (grind) nil nil)) nil)
           ("5" (typepred lflag)
            (("5" (ground)
              (("1" (skeep*)
                (("1" (inst - i n)
                  (("1" (hide -1 3) (("1" (grind) nil nil)) nil)) nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil)
               ("3" (skeep*)
                (("3" (inst - i n)
                  (("3" (hide -2 -5 -7) (("3" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint64 type-eq-decl nil integertypes nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (empty? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (step subtype "pegtopdown.loop?(pegtopdown.newentry)"
         "{b: booleans.bool | IF b THEN booleans.OR(pegtopdown.nt(pegtopdown.rest) = pegtopdown.num_non_terminals, pegtopdown.loop_ready?(pegtopdown.len, pegtopdown.G, pegtopdown.St`scaf WITH [(pegtopdown.pos)(pegtopdown.cur) := pegtopdown.newentry], pegtopdown.pos(pegtopdown.rest), pegtopdown.nt(pegtopdown.rest))) ELSE FORALL (i: naturalnumbers.upto(pegtopdown.len)), n: (booleans.NOT)(pegtopdown.loop?(pegtopdown.St`scaf WITH [(pegtopdown.pos)(pegtopdown.cur) := pegtopdown.newentry](i)(pegtopdown.n))) ENDIF}")))
 (size_TCC1 0
  (size_TCC1-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (size subtype "pegtopdown.len"
         "naturalnumbers.upto(pegtopdown.len)")))
 (size_TCC2 0
  (size_TCC2-1 nil 3809191050
   ("" (skeep*)
    (("" (typepred "St`depth")
      (("" (expand good_depth?)
        (("" (expand pushcount)
          (("" (use sigma_max) (("" (grind :exclude exp2) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (uint32 type-eq-decl nil integertypes nil)
    (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (sigma def-decl "real" sigma reals)
    (scafcount const-decl "uint64" pegtopdown nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (size subtype
         "(number_fields.-)((number_fields.*(((number_fields.+)(pegtopdown.len, 1)), pegtopdown.num_non_terminals)), pegtopdown.St`depth)"
         "nat")))
 (parse_TCC1 0
  (parse_TCC1-1 nil 3809191050
   ("" (use well_founded_le) (("" (grind :exclude <) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (restrict const-decl "R" restrict nil)
    (well_founded_le formula-decl nil ordinals nil))
   nil
   (parse well-founded
          "restrict[[ordstruct_adt.ordstruct, ordstruct_adt.ordstruct], [ordinal, ordinal], booleans.bool].restrict(ordinals.<)"
          "nil")))
 (parse_TCC2 0
  (parse_TCC2-1 nil 3809191050
   ("" (skeep*) (("" (typepred "St`stack") (("" (grind) nil nil)) nil))
    nil)
   ((state type-eq-decl nil pegtopdown nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (strings type-eq-decl nil pegtopdown nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (string type-eq-decl nil strings nil)
    (char type-eq-decl nil strings nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (character type-decl nil character_adt nil)
    (below type-eq-decl nil nat_types nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (uint32 type-eq-decl nil integertypes nil)
    (exp2 def-decl "posnat" exp2 nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (successor const-decl "bool" pegtopdown nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (parse subtype "pegtopdown.St"
          "pegtopdown.endstate(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.start, pegtopdown.root)")))
 (parse_TCC3 0
  (parse_TCC3-1 nil 3809191050
   ("" (skeep*)
    (("" (expand restrict)
      (("" (expand size)
        (("" (rewrite lex2_lt)
          (("1" (flatten)
            (("1" (hide 3)
              (("1" (typepred "St`stack")
                (("1" (apply (then (expand step) (lift-if) (ground)))
                  (("1" (hide 1) (("1" (grind) nil nil)) nil)
                   ("2" (rewrite scafcount_update)
                    (("1" (grind :defs nil)
                      (("1"
                        (typepred
                         "newentry(len, G, s, start, root)(St)")
                        (("1" (grind) nil nil)) nil)
                       ("2" (reveal 1)
                        (("2" (ground)
                          (("1" (expand step)
                            (("1" (rewrite scafcount_update)
                              (("1"
                                (grind :defs nil)
                                (("1"
                                  (typepred
                                   "newentry(len, G, s, start, root)(St)")
                                  (("1"
                                    (grind :exclude newentry)
                                    nil
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (typepred
                                 "newentry(len, G, s, start, root)(St)")
                                (("2"
                                  (grind :exclude newentry)
                                  nil
                                  nil))
                                nil)
                               ("3"
                                (typepred
                                 "newentry(len, G, s, start, root)(St)")
                                (("3"
                                  (grind :exclude newentry)
                                  nil
                                  nil))
                                nil)
                               ("4"
                                (typepred
                                 "newentry(len, G, s, start, root)(St)")
                                (("4"
                                  (grind :exclude newentry)
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand step) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("3"
                        (typepred
                         "newentry(len, G, s, start, root)(St)")
                        (("3" (grind :exclude newentry) nil nil)) nil))
                      nil)
                     ("2"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("2" (grind :exclude newentry) nil nil)) nil)
                     ("3"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("3" (grind :exclude newentry) nil nil)) nil)
                     ("4"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("4" (grind :exclude newentry) nil nil)) nil))
                    nil)
                   ("3" (rewrite scafcount_update)
                    (("1" (grind :defs nil)
                      (("1" (grind) nil nil)
                       ("2"
                        (typepred
                         "newentry(len, G, s, start, root)(St)")
                        (("2" (grind :exclude newentry) nil nil)) nil)
                       ("3" (grind) nil nil))
                      nil)
                     ("2"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("2" (grind :exclude newentry) nil nil)) nil)
                     ("3"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("3" (grind :exclude newentry) nil nil)) nil)
                     ("4"
                      (typepred "newentry(len, G, s, start, root)(St)")
                      (("4" (grind :exclude newentry) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 3)
            (("2" (typepred "St`depth")
              (("2" (grind :exclude scafcount)
                (("2" (use sigma_max) (("2" (ground) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (hide 2)
            (("3" (typepred "step(len, G, s, start, root)(St)`depth")
              (("3" (grind :exclude (step scafcount))
                (("1" (use sigma_max) (("1" (ground) nil nil)) nil)
                 ("2" (use sigma_max) (("2" (ground) nil nil)) nil)
                 ("3" (use sigma_max) (("3" (ground) nil nil)) nil)
                 ("4" (use sigma_max) (("4" (ground) nil nil)) nil)
                 ("5" (use sigma_max) (("5" (ground) nil nil)) nil)
                 ("6" (use sigma_max) (("6" (ground) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restrict const-decl "R" restrict nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (lex2_lt formula-decl nil lex2 nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil) (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (uint64 type-eq-decl nil integertypes nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (peg type-decl nil pegtopdown nil)
    (lang_spec type-eq-decl nil pegtopdown nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (strings type-eq-decl nil pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (nt adt-accessor-decl "[(push?) -> uint8]" pegtopdown nil)
    (loop_ready? const-decl "bool" pegtopdown nil)
    (pos adt-accessor-decl "[(push?) -> uint32]" pegtopdown nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (loop? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (state type-eq-decl nil pegtopdown nil)
    (step const-decl "state(len, G, s, start, rootnt)" pegtopdown nil)
    (push_or_pending? const-decl "bool" pegtopdown nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (empty? const-decl "bool" pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fine_entry? const-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (loop_or_push? const-decl "bool" pegtopdown nil)
    (fine_push_entry? const-decl "bool" pegtopdown nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences
                 nil)
    (good_fail? const-decl "bool" pegtopdown nil)
    (good_good? const-decl "bool" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (scafcount_update formula-decl nil pegtopdown nil)
    (ne_state type-eq-decl nil pegtopdown nil)
    (finer_entry? const-decl "bool" pegtopdown nil)
    (finer_entry type-eq-decl nil pegtopdown nil)
    (newentry const-decl
              "finer_entry(len, G, s, St`scaf, St`stack, pos(St`stack), nt(St`stack))"
              pegtopdown nil)
    (sigma_max formula-decl nil pegtopdown nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (< def-decl "bool" ordinals nil)
    (lex2 const-decl "ordinal" lex2 nil)
    (size const-decl "ordinal" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (parse termination
          "pegtopdown.parse(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.start, pegtopdown.root)(pegtopdown.step(pegtopdown.len, pegtopdown.G, pegtopdown.s, pegtopdown.start, pegtopdown.root)(pegtopdown.St))"
          "nil")))
 (doparse_TCC1 0
  (doparse_TCC1-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "pegtopdown.pend"
            "[non_terminal -> (pegtopdown.nice_entry?(pegtopdown.len, pegtopdown.i))]")))
 (doparse_TCC2 0
  (doparse_TCC2-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (doparse subtype "0" "naturalnumbers.upto(pegtopdown.len)")))
 (doparse_TCC3 0
  (doparse_TCC3-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((nil application-judgement "above(n)" exp2 nil)) nil
   (doparse subtype "0" "uint32")))
 (doparse_TCC4 0
  (doparse_TCC4-1 nil 3809191050 ("" (grind) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)
    (exp2 def-decl "posnat" exp2 nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil (doparse subtype "pegtopdown.num_non_terminals" "uint8")))
 (doparse_TCC5 0
  (doparse_TCC5-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "pegtopdown.push(0, pegtopdown.num_non_terminals)"
            "(pegtopdown.nice_entry?(pegtopdown.len, 0))")))
 (doparse_TCC6 0
  (doparse_TCC6-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (good_entry? const-decl "bool" pegtopdown nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (good_root? const-decl "bool" pegtopdown nil)
    (good_or_fail? const-decl "bool" pegtopdown nil)
    (count const-decl "upto(len)" arrayCount nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (gfcount const-decl "uint64" pegtopdown nil)
    (good_tscaffold? const-decl "bool" pegtopdown nil)
    (fine_scaffold? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype
            "(LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): pegtopdown.pend) WITH [(0)(pegtopdown.n) := pegtopdown.push(0, pegtopdown.num_non_terminals)]"
            "(pegtopdown.fine_scaffold?(pegtopdown.len, pegtopdown.G, pegtopdown.s)(0, pegtopdown.n))")))
 (doparse_TCC7 0
  (doparse_TCC7-1 nil 3809191050
   ("" (skeep*)
    (("" (grind :exclude good_depth?)
      (("" (expand good_depth?)
        (("" (expand pushcount)
          (("" (rewrite scafcount_update)
            (("" (use "empty_card[below(255)]")
              (("1" (ground)
                (("1" (replace -2 :hide? t)
                  (("1" (rewrite "reals@sigma[upto(len)].sigma_zero")
                    nil nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (inst + 255 "id[below(255)]")
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (pushcount const-decl "uint64" pegtopdown nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (below type-eq-decl nil naturalnumbers nil)
    (empty_card formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil nat_types nil)
    (FALSE const-decl "bool" booleans nil)
    (sigma_zero formula-decl nil sigma reals)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (restrict const-decl "R" restrict nil)
    (scafcount const-decl "uint64" pegtopdown nil)
    (sigma def-decl "real" sigma reals)
    (count const-decl "upto(len)" arrayCount nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (sigma_nat application-judgement "nat" sigma reals)
    (push adt-constructor-decl "[[uint32, uint8] -> (push?)]"
          pegtopdown nil)
    (uint8 type-eq-decl nil integertypes nil)
    (push? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (pending adt-constructor-decl "(pending?)" pegtopdown nil)
    (pending? adt-recognizer-decl "[ent -> boolean]" pegtopdown nil)
    (scaffold type-eq-decl nil pegtopdown nil)
    (ent type-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (byte type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (uint32 type-eq-decl nil integertypes nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (scafcount_update formula-decl nil pegtopdown nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nice_entry? const-decl "bool" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (good_good_entry? const-decl "bool" pegtopdown nil)
    (good_depth? const-decl "bool" pegtopdown nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "1"
            "(pegtopdown.good_depth?(pegtopdown.len, (LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): pegtopdown.pend) WITH [(0)(pegtopdown.n) := pegtopdown.push(0, pegtopdown.num_non_terminals)]))")))
 (doparse_TCC8 0
  (doparse_TCC8-1 nil 3809191050 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fine_stack? def-decl "bool" pegtopdown nil)
    (mem_stack? def-decl "bool" pegtopdown nil)
    (good_stack? def-decl "bool" pegtopdown nil)
    (successor const-decl "bool" pegtopdown nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (good_push_entry? const-decl "bool" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "pegtopdown.push(0, pegtopdown.n)"
            "(pegtopdown.fine_stack?(pegtopdown.len, pegtopdown.G, 1, (LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): pegtopdown.pend) WITH [(0)(pegtopdown.n) := pegtopdown.push(0, pegtopdown.num_non_terminals)]))")))
 (doparse_TCC9 0
  (doparse_TCC9-1 nil 3809191050 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (exp2 def-decl "posnat" exp2 nil)
    (uint32 type-eq-decl nil integertypes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (character type-decl nil character_adt nil)
    (char? adt-recognizer-decl "[character -> boolean]" character_adt
     nil)
    (char type-eq-decl nil strings nil)
    (string type-eq-decl nil strings nil)
    (strings type-eq-decl nil pegtopdown nil)
    (< const-decl "bool" reals nil)
    (byte type-eq-decl nil pegtopdown nil)
    (non_terminal type-eq-decl nil pegtopdown nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (num_non_terminals const-decl "byte" pegtopdown nil)
    (nil application-judgement "above(n)" exp2 nil))
   nil
   (doparse subtype "booleans.FALSE"
            "{b: booleans.bool | IF b THEN booleans.OR(pegtopdown.n = pegtopdown.num_non_terminals, pegtopdown.loop_ready?(pegtopdown.len, pegtopdown.G, (LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): pegtopdown.pend) WITH [(0)(pegtopdown.n) := pegtopdown.push(0, pegtopdown.num_non_terminals)], 0, pegtopdown.n)) ELSE FORALL (i_1: naturalnumbers.upto(pegtopdown.len)), (n_1: pegtopdown.non_terminal): (booleans.NOT)(pegtopdown.loop?((LAMBDA (i: naturalnumbers.upto(pegtopdown.len)): pegtopdown.pend) WITH [(0)(pegtopdown.n) := pegtopdown.push(0, pegtopdown.num_non_terminals)](i_1)(n_1))) ENDIF}"))))


$$$pegtopdowntest.pvs
pegtopdowntest 	: THEORY

  BEGIN
   IMPORTING pegtopdown

   digit(c : byte): bool = (c >= 48 AND c <= 57)
   any(c: byte): bool = TRUE

   CONVERSION+ code
   

   pyaml(n: non_terminal): peg =
   COND 
    n = 0 -> choice(1, 3),  %data -> numeral / adata
    n = 1 ->  concat(2, 1),  %numeral -> any(48-57) o numeral
    n = 2 -> any(digit),
    n = 3 -> choice(4, 35),  %adata -> dict / array
    n = 4 -> concat(5, 11),  %dict -> obrace o dictail
    n = 5 -> concat(6, 7),  %obrace -> { o wspace
    n = 6 -> terminal(code("{")), %{
    n = 7 -> choice(8, 10), %wspace ->  wspace$ / epsilon
    n = 8 -> concat(9, 7),  %wspace$ -> terminal(32) o wspace
    n = 9 -> terminal(code(" ")),  %space
    n = 10 -> epsilon,
    n = 11 -> choice(12, 14), %dictail -> cbrace / dictail$
    n = 12 -> concat(13, 7), %cbrace -> terminal(125) o wspace
    n = 13 -> terminal(code("}")),
    n = 14 -> concat(15, 31), % dictail$ -> dictentry o dictailc
    n = 15 -> concat(16, 28), %dictentry -> lhs o seprhs
    n = 16 -> choice(1, 17),  %lhs -> numeral / token
    n = 17 -> concat(18, 7), %token -> token$ o wspace
    n = 18 -> concat(19, 25), %token$ -> terminal(39) o tokentail
    n = 19 -> terminal(code("'")),
    n = 20 -> choice(21, 25), %tokentail-> esctail / qtail
    n = 21 -> concat(22, 20), %esctail -> esquote o tokentail
    n = 22 -> concat(23, 19), %esquote -> terminal(92) o terminal(39)
    n = 23 -> terminal(code("\\")),
    n = 24 -> concat(19, 7), %quote -> terminal(39) o wspace
    n = 25 -> choice(24, 26), %qtail -> quote / tktail
    n = 26 -> concat(27, 20), %tktail -> any o tokentail
    n = 27 -> pegtopdown.any(any),
    n = 28 -> concat(29, 0), %seprhs -> separator o data
    n = 29 -> concat(30, 7), %separator -> terminal(58) o wspace
    n = 30 -> terminal(code(":")),
    n = 31 -> choice(32, 12),  %dictailc -> cdictailc / cbrace
    n = 32 -> concat(33, 14),   %cdictailc -> comma o dictail$
    n = 33 -> concat(34, 7),  %comma -> terminal(44) o wspace 
    n = 34 -> terminal(code(",")),
    n = 35 -> concat(36, 38), %array -> obrack o aentries
    n = 36 -> concat(37, 7), %obrack -> terminal(91) o wspace 
    n = 37 -> terminal(code("[")),
    n = 38 -> choice(39, 43), %aentries -> aentries* o cbrack
    n = 39 -> choice(40, 10), %aentries* -> aentries$ / epsilon
    n = 40 -> concat(0, 41), %aentries$ -> data o aentriestail
    n = 41 -> choice(42, 10), %aentriestail -> centries / epsilon
    n = 42 -> concat(33, 40), %centries -> comma o aentries$
    n = 43 -> concat(44, 7),  %cbrack -> terminal(93) o wspace
    n = 44 -> terminal(code("]")),
    ELSE -> epsilon
    ENDCOND

    len, l1, l2 : VAR uint32
    
%    empty(len)(i:below(len)): byte = 32

    % cat(l1, (l2 : below(exp2(8) - l1)))(s1: strings(l1), s2: strings(l2)): strings(l1 + l2) = 
    %  LAMBDA (i:below(l1 + l2)): IF i < l1 THEN s1(i) ELSE s2(i - l1) ENDIF

    tok0: strings(7) = "'token'"

    % tok0(i : below(7)): byte =
    %  COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 39 ENDCOND

    tok1: strings(9) = "'token\\''"
    
    % tok1(i : below(9)): byte =
    %  COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 92, i = 7 -> 39, i = 8 -> 39 ENDCOND

    emptydict : strings(9) = "{      } "

    % emptydict(i: below(9)): byte = 
    %      COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32, i = 3 -> 32, i = 4 -> 32, i = 5 -> 32, i = 6 -> 32, i = 7 -> 125, i = 8 -> 32 ENDCOND

    obrace: strings(3) = "{  "
    cbrace: strings(3) = "}  "
    colon: strings(3) = ":  "

    % obrace(i: below(3)): byte = COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32 ENDCOND
    % cbrace(i: below(3)): byte = COND i = 0 -> 125, i = 1 -> 32, i = 2 -> 32 ENDCOND
    % colon(i: below(3)): byte = COND i = 0 -> 58, i = 1 -> 32, i = 2 -> 32 ENDCOND
    emptydict2: strings(6) =
      obrace ++ cbrace

    csl(i, j: uint8)(s: strings(j)): RECURSIVE strings(max(0, (i*(j + 2)) - 2))
    = (IF i = 0 THEN ""
       ELSIF i = 1 THEN s
       ELSE s ++ ", " ++ csl(i-1, j)(s)
       ENDIF)
       MEASURE i

    array_of_emptydicts(i: uint16): strings(11*i) =
        "[" ++ csl(i, 9)(emptydict) ++ "]"

    dict1: strings(22) =
      obrace ++ tok0 ++ colon ++ emptydict2 ++ cbrace

    test0: ent = doparse(2, pyaml, "  ", 7)
    test0eval: LEMMA good?(test0)
     
    test1: ent = doparse(7, pyaml, tok0, 17)
    test11: ent = doparse(9, pyaml, tok1, 17)
    test2: ent = doparse(22, pyaml, dict1, 0)

    test_emptydicts(i: nat): ent = doparse(9*i, pyaml, array_of_emptydicts(i), 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    pparens(n: non_terminal): peg =
   COND 
    n = 0 -> choice(1, 6),  
    n = 1 ->  concat(2, 3),  
    n = 2 -> terminal(code("(")),
    n = 3 -> concat(0, 4),  
    n = 4 -> concat(5, 0),  
    n = 5 -> terminal(code(")")),
    n = 6 -> epsilon,
    ELSE -> epsilon
   ENDCOND

   testparens0: ent = doparse(8, pparens, "(()())()", 0)
   testparens1: ent = doparse(9, pparens, "((()())()", 0)
   testparens2: ent = doparse(9, pparens, "(()()))()", 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    ppow(n: non_terminal): peg =
   COND 
    n = 0 -> concat(1, 10), 
    n = 1 ->  choice(2, 5),  
    n = 2 -> concat(3, 4), 
    n = 3 -> any(LAMBDA (c: byte): true),
    n = 4 -> concat(1, 3), 
    n = 5 -> choice(6, 9), 
    n = 6 -> concat(3, 7),
    n = 7 -> concat(8, 3),
    n = 8 -> check(1),
    n = 9 -> epsilon,
    n = 10 -> neg(3),
    ELSE -> epsilon
   ENDCOND

   testpow0: ent = doparse(6, ppow, "parsed", 0)
   testpow1: ent = doparse(8, ppow, "reparsed", 0)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    ploop(n: non_terminal): peg =
   COND 
    n = 0 -> concat(1, 10), 
    n = 1 ->  concat(2, 4),  
    n = 2 -> neg(3),
    n = 3 -> terminal(code("c")),
    n = 4 -> concat(5, 8),
    n = 5 -> choice(6, 7), 
    n = 6 -> terminal(code("a")),
    n = 7 -> epsilon,
    n = 8 -> choice(9, 7),
    n = 9 -> terminal(code("b")),
    n = 10 -> choice(11, 0),
    n = 11 -> terminal(code("#")),
    ELSE -> epsilon
   ENDCOND

   testloop0: ent = doparse(6, ploop, "abbda#e", 0)
   testloop1: ent = doparse(8, ploop, "abbca#e", 0)




    
  END pegtopdowntest

$$$pegtopdowntest.prf
(pegtopdowntest
 (pyaml_TCC1 0
  (pyaml_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "1" "non_terminal")))
 (pyaml_TCC2 0
  (pyaml_TCC2-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "3" "non_terminal")))
 (pyaml_TCC3 0
  (pyaml_TCC3-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "2" "non_terminal")))
 (pyaml_TCC4 0
  (pyaml_TCC4-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "1" "non_terminal")))
 (pyaml_TCC5 0
  (pyaml_TCC5-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "4" "non_terminal")))
 (pyaml_TCC6 0
  (pyaml_TCC6-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "35" "non_terminal")))
 (pyaml_TCC7 0
  (pyaml_TCC7-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "5" "non_terminal")))
 (pyaml_TCC8 0
  (pyaml_TCC8-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "11" "non_terminal")))
 (pyaml_TCC9 0
  (pyaml_TCC9-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "6" "non_terminal")))
 (pyaml_TCC10 0
  (pyaml_TCC10-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC11 0
  (pyaml_TCC11-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"{\"" "{fs | fs`length = 1}")))
 (pyaml_TCC12 0
  (pyaml_TCC12-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "8" "non_terminal")))
 (pyaml_TCC13 0
  (pyaml_TCC13-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "10" "non_terminal")))
 (pyaml_TCC14 0
  (pyaml_TCC14-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "9" "non_terminal")))
 (pyaml_TCC15 0
  (pyaml_TCC15-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC16 0
  (pyaml_TCC16-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\" \"" "{fs | fs`length = 1}")))
 (pyaml_TCC17 0
  (pyaml_TCC17-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "12" "non_terminal")))
 (pyaml_TCC18 0
  (pyaml_TCC18-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "14" "non_terminal")))
 (pyaml_TCC19 0
  (pyaml_TCC19-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "13" "non_terminal")))
 (pyaml_TCC20 0
  (pyaml_TCC20-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC21 0
  (pyaml_TCC21-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"}\"" "{fs | fs`length = 1}")))
 (pyaml_TCC22 0
  (pyaml_TCC22-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "15" "non_terminal")))
 (pyaml_TCC23 0
  (pyaml_TCC23-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "31" "non_terminal")))
 (pyaml_TCC24 0
  (pyaml_TCC24-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "16" "non_terminal")))
 (pyaml_TCC25 0
  (pyaml_TCC25-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "28" "non_terminal")))
 (pyaml_TCC26 0
  (pyaml_TCC26-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "1" "non_terminal")))
 (pyaml_TCC27 0
  (pyaml_TCC27-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "17" "non_terminal")))
 (pyaml_TCC28 0
  (pyaml_TCC28-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "18" "non_terminal")))
 (pyaml_TCC29 0
  (pyaml_TCC29-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC30 0
  (pyaml_TCC30-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "19" "non_terminal")))
 (pyaml_TCC31 0
  (pyaml_TCC31-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "25" "non_terminal")))
 (pyaml_TCC32 0
  (pyaml_TCC32-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"'\"" "{fs | fs`length = 1}")))
 (pyaml_TCC33 0
  (pyaml_TCC33-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "21" "non_terminal")))
 (pyaml_TCC34 0
  (pyaml_TCC34-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "25" "non_terminal")))
 (pyaml_TCC35 0
  (pyaml_TCC35-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "22" "non_terminal")))
 (pyaml_TCC36 0
  (pyaml_TCC36-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "20" "non_terminal")))
 (pyaml_TCC37 0
  (pyaml_TCC37-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "23" "non_terminal")))
 (pyaml_TCC38 0
  (pyaml_TCC38-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "19" "non_terminal")))
 (pyaml_TCC39 0
  (pyaml_TCC39-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"\\\\\\\\\"" "{fs | fs`length = 1}")))
 (pyaml_TCC40 0
  (pyaml_TCC40-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "19" "non_terminal")))
 (pyaml_TCC41 0
  (pyaml_TCC41-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC42 0
  (pyaml_TCC42-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "24" "non_terminal")))
 (pyaml_TCC43 0
  (pyaml_TCC43-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "26" "non_terminal")))
 (pyaml_TCC44 0
  (pyaml_TCC44-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "27" "non_terminal")))
 (pyaml_TCC45 0
  (pyaml_TCC45-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "20" "non_terminal")))
 (pyaml_TCC46 0
  (pyaml_TCC46-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "29" "non_terminal")))
 (pyaml_TCC47 0
  (pyaml_TCC47-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "0" "non_terminal")))
 (pyaml_TCC48 0
  (pyaml_TCC48-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "30" "non_terminal")))
 (pyaml_TCC49 0
  (pyaml_TCC49-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC50 0
  (pyaml_TCC50-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\":\"" "{fs | fs`length = 1}")))
 (pyaml_TCC51 0
  (pyaml_TCC51-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "32" "non_terminal")))
 (pyaml_TCC52 0
  (pyaml_TCC52-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "12" "non_terminal")))
 (pyaml_TCC53 0
  (pyaml_TCC53-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "33" "non_terminal")))
 (pyaml_TCC54 0
  (pyaml_TCC54-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "14" "non_terminal")))
 (pyaml_TCC55 0
  (pyaml_TCC55-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "34" "non_terminal")))
 (pyaml_TCC56 0
  (pyaml_TCC56-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC57 0
  (pyaml_TCC57-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\",\"" "{fs | fs`length = 1}")))
 (pyaml_TCC58 0
  (pyaml_TCC58-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "36" "non_terminal")))
 (pyaml_TCC59 0
  (pyaml_TCC59-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "38" "non_terminal")))
 (pyaml_TCC60 0
  (pyaml_TCC60-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "37" "non_terminal")))
 (pyaml_TCC61 0
  (pyaml_TCC61-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC62 0
  (pyaml_TCC62-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"[\"" "{fs | fs`length = 1}")))
 (pyaml_TCC63 0
  (pyaml_TCC63-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "39" "non_terminal")))
 (pyaml_TCC64 0
  (pyaml_TCC64-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "43" "non_terminal")))
 (pyaml_TCC65 0
  (pyaml_TCC65-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "40" "non_terminal")))
 (pyaml_TCC66 0
  (pyaml_TCC66-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "10" "non_terminal")))
 (pyaml_TCC67 0
  (pyaml_TCC67-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "0" "non_terminal")))
 (pyaml_TCC68 0
  (pyaml_TCC68-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "41" "non_terminal")))
 (pyaml_TCC69 0
  (pyaml_TCC69-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "42" "non_terminal")))
 (pyaml_TCC70 0
  (pyaml_TCC70-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "10" "non_terminal")))
 (pyaml_TCC71 0
  (pyaml_TCC71-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "33" "non_terminal")))
 (pyaml_TCC72 0
  (pyaml_TCC72-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "40" "non_terminal")))
 (pyaml_TCC73 0
  (pyaml_TCC73-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "44" "non_terminal")))
 (pyaml_TCC74 0
  (pyaml_TCC74-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (pyaml subtype "7" "non_terminal")))
 (pyaml_TCC75 0
  (pyaml_TCC75-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil))
   nil (pyaml subtype "\"]\"" "{fs | fs`length = 1}")))
 (tok0_TCC1 0
  (tok0_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (tok0 subtype "7" "uint32")))
 (tok0_TCC2 0
  (tok0_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (tok0 subtype "\"'token'\"" "pegtopdown.strings(7)")))
 (tok1_TCC1 0
  (tok1_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (tok1 subtype "9" "uint32")))
 (tok1_TCC2 0
  (tok1_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (tok1 subtype "\"'token\\\\\\\\''\"" "pegtopdown.strings(9)")))
 (emptydict_TCC1 0
  (emptydict_TCC1-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (emptydict subtype "\"{      } \"" "pegtopdown.strings(9)")))
 (obrace_TCC1 0
  (obrace_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (obrace subtype "3" "uint32")))
 (obrace_TCC2 0
  (obrace_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (obrace subtype "\"{  \"" "pegtopdown.strings(3)")))
 (cbrace_TCC1 0
  (cbrace_TCC1-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (cbrace subtype "\"}  \"" "pegtopdown.strings(3)")))
 (colon_TCC1 0
  (colon_TCC1-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (colon subtype "\":  \"" "pegtopdown.strings(3)")))
 (emptydict2_TCC1 0
  (emptydict2_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (emptydict2 subtype "6" "uint32")))
 (emptydict2_TCC2 0
  (emptydict2_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (obrace const-decl "strings(3)" pegtopdowntest nil)
    (cbrace const-decl "strings(3)" pegtopdowntest nil)
    (O const-decl "finseq" finite_sequences nil)
    (concat const-decl "string" stdstr nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (emptydict2 subtype
    "stdstr.concat(pegtopdowntest.obrace, pegtopdowntest.cbrace)"
    "pegtopdown.strings(6)")))
 (dict1_TCC1 0
  (dict1_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (dict1 subtype "22" "uint32")))
 (dict1_TCC2 0
  (dict1_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (obrace const-decl "strings(3)" pegtopdowntest nil)
    (tok0 const-decl "strings(7)" pegtopdowntest nil)
    (colon const-decl "strings(3)" pegtopdowntest nil)
    (cbrace const-decl "strings(3)" pegtopdowntest nil)
    (O const-decl "finseq" finite_sequences nil)
    (concat const-decl "string" stdstr nil)
    (emptydict2 const-decl "strings(6)" pegtopdowntest nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (dict1 subtype
    "stdstr.concat(pegtopdowntest.obrace, stdstr.concat(pegtopdowntest.tok0, stdstr.concat(pegtopdowntest.colon, stdstr.concat(pegtopdowntest.emptydict2, pegtopdowntest.cbrace))))"
    "pegtopdown.strings(22)")))
 (test0_TCC1 0
  (test0_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil) nil nil
   (test0 subtype "2" "uint32")))
 (test0_TCC2 0
  (test0_TCC2-1 nil 3809380981 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (list2finseq const-decl "finseq[T]" list2finseq nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil (test0 subtype "\"  \"" "pegtopdown.strings(2)")))
 (test0_TCC3 0
  (test0_TCC3-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (test0 subtype "7" "non_terminal")))
 (test1_TCC1 0
  (test1_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (test1 subtype "17" "non_terminal")))
 (test2_TCC1 0
  (test2_TCC1-1 nil 3809380981 ("" (subtype-tcc) nil nil)
   ((num_non_terminals const-decl "byte" pegtopdown nil)) nil
   (test2 subtype "0" "non_terminal"))))

