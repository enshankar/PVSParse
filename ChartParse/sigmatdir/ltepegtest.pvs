ltepegtest 	: THEORY

  BEGIN
   IMPORTING ltepegproof

   digit(x: byte): bool = (x >= 48 AND x <= 57)
   any(x: byte): bool = TRUE
   whitespace(x: byte): bool = (x = 32 OR (x >= 9 AND x <= 13))

   ljson: ARRAY[non_terminal -> prepeg] =
   (LAMBDA (n: non_terminal): 
   COND
   n = 0 -> lte(18, 1, 2), % data -> digit ? numeral$ / adata
   n = 1 -> lte(18, 1, 3), % numeral$ -> digit ? numeral$ / wspace
   n = 2 -> lte(27, 4, 6), % adata -> obrace ? dictail / stringarray
   n = 3 -> lte(17, 3, 34), % wspace -> space ? wspace / epsilon
   n = 4 -> lte(28, 34, 5), % dictail -> cbrace ? epsilon / dictentry*
   n = 5 -> lte(7, 11, 33), % dictentry* -> token ? rhsdata* / fail
   n = 6 -> lte(7, 34, 10), % stringarray -> token ? epsilon / array
   n = 7 -> lte(24, 8, 33), % token -> quote ? tokentail / fail
   n = 8 -> lte(24, 3, 9), % tokentail -> quote ? wspace / tokentail$
   n = 9 -> lte(19, 8, 33), % tokentail$ -> any ? tokentail / fail
   n = 10 -> lte(30, 14, 33), % array -> obrack ? arraydata* / fail
   n = 11 -> lte (32, 12, 33), % rhsdata* -> colon ? rhsdatatail / fail
   n = 12 -> lte(0, 13, 33), % rhsdatatail -> data ? commadictail / fail
   n = 13 -> lte(31, 4, 28), % commadictail -> comma ? dictail / cbrace
   n = 14 -> lte(30, 3, 16),  % arraydata* -> cbrack ? wspace / arraydatadata*
   n = 15 -> lte(31, 16, 30), % commaarraydata* -> comma ? arraydatdata* / cbrack 
   n = 16 -> lte(0, 15, 33), % arraydatadata* -> data ? commaarraydata* / fail
   n = 17 -> any(whitespace), % space -> any(wspace)
   n = 18 -> any(digit), % digit -> any(digit)
   n = 19 -> any(any), % any -> any(any)
   n = 20 -> terminal(123), % obracechar -> terminal(123)
   n = 21 -> terminal(125), % cbracechar -> terminal(125)
   n = 22 -> terminal(91), % obrackchar -> terminal(91)
   n = 23 -> terminal(93), % cbrackchar -> terminal(93)
   n = 24 -> terminal(34), % quote -> terminal(34)
   n = 25 -> terminal(44), % commachar -> termina(44)
   n = 26 -> terminal(58), % colonchar -> terminal(58)
   n = 27 -> lte(20, 3, 33), % obrace -> obracechar ? wspace / fail
   n = 28 -> lte(21, 3, 33), % cbrace -> cbracechar ? wspace / fail
   n = 29 -> lte(22, 3, 33), % obrack -> obrackchar ? wspace / fail
   n = 30 -> lte(23, 3, 33), % cbrack -> cbrackchar ? wspace / fail
   n = 31 -> lte(25, 3, 33), % comma -> commachar ? wspace / fail
   n = 32 -> lte(26, 3, 33), % colon -> colonchar ? wspace / fail
   n = 33 -> failure, % fail -> failure
   ELSE -> epsilon
   ENDCOND)

   % pjson: ARRAY[non_terminal -> peg] =
   % (LAMBDA (n: non_terminal): 
   % COND 
   %  n = 0 -> choice(1, 3),  %data -> numeral / adata
   %  n = 1 -> concat(46, 2), %numeral -> any(48-57) o numeral$
   %  n = 2 -> choice(1, 7),  %numeral$ -> numeral / wspace
   %  n = 3 -> choice(4, 35),  %adata -> dict / stringarray
   %  n = 4 -> concat(5, 11),  %dict -> obrace o dictail
   %  n = 5 -> concat(6, 7),  %obrace -> { o wspace
   %  n = 6 -> terminal(123), %{
   %  n = 7 -> choice(8, 10), %wspace ->  wspace$ / epsilon
   %  n = 8 -> concat(9, 7),  %wspace$ -> space o wspace
   %  n = 9 -> any(whitespace),  %space
   %  n = 10 -> epsilon,
   %  n = 11 -> choice(12, 14), %dictail -> cbrace / dictail$
   %  n = 12 -> concat(13, 7), %cbrace -> terminal(125) o wspace
   %  n = 13 -> terminal(125),
   %  n = 14 -> concat(15, 31), % dictail$ -> dictentry o dictailc
   %  n = 15 -> concat(16, 28), %dictentry -> lhs o seprhs
   %  n = 16 -> choice(1, 17),  %lhs -> numeral / token
   %  n = 17 -> concat(18, 7), %token -> token$ o wspace
   %  n = 18 -> concat(19, 25), %token$ -> terminal(34) o tokentail
   %  n = 19 -> terminal(34),
   %  n = 20 -> choice(21, 25), %tokentail-> esctail / qtail
   %  n = 21 -> concat(22, 20), %esctail -> esquote o tokentail
   %  n = 22 -> concat(23, 19), %esquote -> terminal(92) o terminal(34)
   %  n = 23 -> terminal(92),
   %  n = 24 -> concat(19, 7), %quote -> terminal(34) o wspace
   %  n = 25 -> choice(24, 26), %qtail -> quote / tktail
   %  n = 26 -> concat(27, 20), %tktail -> any o tokentail
   %  n = 27 -> any(any),
   %  n = 28 -> concat(29, 0), %seprhs -> separator o data
   %  n = 29 -> concat(30, 7), %separator -> terminal(58) o wspace
   %  n = 30 -> terminal(58),
   %  n = 31 -> choice(32, 12),  %dictailc -> cdictailc / cbrace
   %  n = 32 -> concat(33, 14),   %cdictailc -> comma o dictail$
   %  n = 33 -> concat(34, 7),  %comma -> terminal(44) o wspace 
   %  n = 34 -> terminal(44),
   %  n = 35 -> choice(17, 36), %stringarray -> token/array
   %  n = 36 -> concat(37, 39), %array -> obrack o aentries
   %  n = 37 -> concat(38, 7), %obrack -> terminal(91) o wspace 
   %  n = 38 -> terminal(91),
   %  n = 39 -> concat(40, 44), %aentries -> aentries* o cbrack
   %  n = 40 -> choice(41, 7), %aentries* -> aentries$ / wspace
   %  n = 41 -> concat(0, 42), %aentries$ -> data o aentriestail
   %  n = 42 -> choice(43, 7), %aentriestail -> centries / wspace
   %  n = 43 -> concat(33, 41), %centries -> comma o aentries$
   %  n = 44 -> concat(45, 7),  %cbrack -> terminal(93) o wspace
   %  n = 45 -> terminal(93),
   %  n = 46 -> any(digit),
   %  ELSE -> epsilon
   %  ENDCOND)


    len, l1, l2 : VAR uint8
    
    empty(len):  strings(len) = (LAMBDA (i:below(len)): 32)

    cat(l1, (l2 : below(I[uint8](exp2(8) - l1))))(s1: strings(l1), s2: strings(I[uint8](l2))): strings(I[uint8](l1 + l2)) = 
     LAMBDA (i:below(l1 + l2)): IF i < l1 THEN s1(i) ELSE s2(i - l1) ENDIF

    tok0: strings(7) =
    (LAMBDA (i : below(7)): 
     COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 39 ENDCOND)
    
    tok1: strings(9) =
     (LAMBDA (i : below(9)): COND i = 0 -> 39, i = 1 -> 116, i = 2 -> 111, i = 3 -> 107, i = 4 -> 101, i = 5 -> 110, i = 6 -> 92, i = 7 -> 39, i = 8 -> 39 ENDCOND)

    emptydict: strings(9) = 
       (LAMBDA (i: below(9)):   COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32, i = 3 -> 32, i = 4 -> 32, i = 5 -> 32, i = 6 -> 32, i = 7 -> 125, i = 8 -> 32 ENDCOND)

    obrace: strings(3) = (LAMBDA (i: below(3)): COND i = 0 -> 123, i = 1 -> 32, i = 2 -> 32 ENDCOND)
    cbrace: strings(3) = (LAMBDA (i: below(3)): COND i = 0 -> 125, i = 1 -> 32, i = 2 -> 32 ENDCOND)
    colon: strings(3) = (LAMBDA (i: below(3)): COND i = 0 -> 58, i = 1 -> 32, i = 2 -> 32 ENDCOND)
    emptydict2: strings(6) =
      cat(3, 3)(obrace, cbrace)

    dict1: strings(22) =
      cat(3, 19)(obrace, cat(7, 12)(tok0, cat(3, 9)(colon, cat(6, 3)(emptydict2, cbrace))))


    G: VAR lang_spec
    n: VAR non_terminal

    % test4: ent = doparse(144, pjson, mk_bytestring("{\"protocols\" : {\"AKA\" : {      \"name\" : \"AKA\",      \"actors\" : {        \"UE\" : {          \"name\":\"UE\",          }      }    }  }}"), 0)

    iparse(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal)): ent
    = (LET pend = (LAMBDA n: pending),
          St: state(len, G, s, start, root) = (# 
 		 stack := push(start, root),
		 depth := 1,
		 lflag := FALSE, 
 		 scaf := (LAMBDA (i: upto(len)): pend) WITH [(start)(root) := push(0, num_non_terminals)] #)
      IN parse(len, G, s, start, root, St)`scaf(start)(root))

    jsonparsefile(fn: bytestring): parsetree =
     (LET lf: lifted_file = open(fn)
     IN IF pass?(lf)
       THEN LET f: file = contents(lf),
                fs : uint32 = file_size(f),
		fstr: bytestring = getbytestring(f, 0, fs),
		pend = (LAMBDA n: pending),
                St: state(fs, ljson, fstr`seq, 0, 0) = (# 
 		stack := push(0, 0),
		depth := 1,
 		scaf := (LAMBDA (i: upto(fs)): pend) WITH [(0)(0) := push(0, num_non_terminals)],
		lflag := FALSE #)
	     IN buildproof(fs, ljson, fstr`seq, 0, 0)(parse(fs, ljson, fstr`seq, 0, 0, St), 0, 0)
       ELSE zero(fail(0))
       ENDIF)

  END ltepegtest
