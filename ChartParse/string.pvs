string : THEORY

  BEGIN

   string: TYPE+
   s, s1, s2: VAR string

   char: TYPE+

   c, c1, c2: VAR char

   code(c): below(256)

   codeExt: AXIOM
     code(c1) = code(c2) ⇒ c1 = c2

   length(s): nat

   char(s)(i: below(length(s))): char

   lstring(i: nat): TYPE = {s: string | length(s) = i}

   empty: string

   length_empty: AXIOM length(empty) = 0

   JUDGEMENT empty HAS_TYPE lstring(0)

   extensionality: AXIOM
       s1 = s2 IFF (length(s1) = length(s2) AND ∀ (i:below(length(s1))): char(s1)(i) = char(s2)(i));

   +(s1, s2): string

   length_concat: AXIOM length(s1 + s2) = length(s1) + length(s2)

   JUDGEMENT +(s1, s2) HAS_TYPE  lstring(length(s1) + length(s2))

   char_concat: AXIOM
       (FORALL (i: below(length(s1) + length(s2))):
         char(s1 + s2)(i)  =
             IF i < length(s1)
                THEN char(s1)(i)
                ELSE char(s2)(i - length(s1))
             ENDIF)

   substr(s)(i: upto(length(s)), j : subrange(i, length(s))): string

   substr_length: AXIOM
   (FORALL (i: upto(length(s)), j : subrange(i, length(s))): 
     length(substr(s)(i, j)) = j - i)
     
  substr_ax: AXIOM
    (FORALL (i: upto(length(s))), (j : subrange(i, length(s))), (k : below(j - i)): 
     char(substr(s)(i, j))(k) = char(s)(i + k))

  prefix(s)(i: upto(length(s))): string = substr(s)(0, i)
  suffix(s)(i: upto(length(s))): string = substr(s)(i, length(s))

   prefix_suffix: LEMMA
     (FORALL (i: upto(length(s))): 
      prefix(s)(i) + suffix(s)(i) = s)


   JUDGEMENT substr(s)(i: upto(length(s)), j : subrange(i, length(s))) HAS_TYPE lstring(j - i)
   JUDGEMENT prefix(s)(i: upto(length(s))) HAS_TYPE lstring(i)
   JUDGEMENT suffix(s)(i: upto(length(s))) HAS_TYPE lstring(length(s)- i)

  END string

