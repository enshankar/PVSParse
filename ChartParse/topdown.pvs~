topdown[num_non_terminals : posnat, terminal_type : TYPE+]
		: THEORY

  BEGIN
IMPORTING scaf[num_non_terminals, terminal_type]



len: VAR nat %the length of the input

%The scaffold entry can be fail, loop, good(span), or pending.

good_entry?(len, (pos: upto(len)))(x: entry): bool = (good?(x) IMPLIES pos + span(x) <= len)

scaffold(len) : TYPE = [pos: upto(len) -> [non_terminal -> (good_entry?(len, pos))]]

stackentry: TYPE = [# pos: upto(len), nonterm: non_terminal #]

pn: VAR stackentry

loop_or_pending?(e: entry): bool = (loop?(e) or pending?(e))

state(len, G, (s: strings(len)), (pos: upto(len)), (root: non_terminal)): TYPE
    = [# stack: list[stackentry],
         scaf: (fine_stack_scaffold?(len, G, s)(pos, root, stack)) #]

tdstack_scaffold?(len, G, (s: strings(len)), (i : upto(len)), (stack: list[non_terminal]))(A : scaffold(len)): bool =
   (FORALL m: member(m, stack) => loop_or_pending?(A(m`pos)(m`nonterm)))

fine_tdstack_scaffold?(len, G, (s: strings(len)))((i : upto(len)), (root: non_terminal), (stack: list[non_terminal]))(A : scaffold(len)): bool =
   fine_scaffold?(len, G, s)(i, stack, root)(A) AND
   tdstack_scaffold?(len, G, s, i, stack)(A) AND
   (cons?(stack) => member(root, stack))


putstack(len, G, (s: strings(len)), (pos: upto(len)), (root: non_terminal))(St: state(len, G, s, pos, root) | NOT null?(St`stack))(pn | pending?(St`scaf(pn`pos)(pn`nonterm)))
   : state(len, G, s, pos, root)
 = (IF member(pn, St`stack)
       THEN St WITH [`scaf(St`pos)(n) := loop]
       ELSE St WITH [`stack := cons(pn, St`stack)]
       ENDIF)

step(len, G, (s: strings(len)), (start: upto(len)), (root: non_terminal))(St : state(len, G, s, start, root)): state(len, G, s, start, root)
 = (LET scaf = St`scaf,
	stack = St`stack
     IN
    IF null?(stack)
    THEN IF pending?(scaf(pos)(root))
         THEN step(len, G, s, start, root)(St WITH [`stack := cons])((# pos := start, nonterm := root #), null)
         ELSE St
	 ENDIF
    ELSE LET pos = stack`car`pos,
             nonterm = stack`car`nonterm,
	     rest = stack`cdr
	  IN CASES G(nonterm) OF
            epsilon: St WITH [`scaf(pos)(nonterm) := good(0), `stack := rest],
	    failure: St WITH [`scaf(pos)(nonterm) := fail, `stack := rest],
	    any: (LET v = IF pos = len THEN fail ELSE good(1) ENDIF
	           IN St WITH [`scaf(pos)(nonterm) := v, `stack := rest]),
            terminal(a): (LET v = IF pos = len OR a /= s(ps) THEN fail ELSE good(1) ENDIF
	                   IN St WITH [`scaf(c)(pos) := v, `stack := rest]),
            concat(n1, n2): (CASES St`scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest],
			      loop: St WITH [`scaf(pos)(cur) := loop, `stack := rest],
			      good(sp): CASES St`scaf(pos + sp)(n2) OF
			                   fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest],
					   loop : St WITH [`scaf(pos)(cur) := loop, `stack := rest],
					   good(sp2): St WITH [`scaf(pos)(cur) := good(sp + sp2), `stack := rest],
					   pending: putstack(len, G, s)(St)(n2)
					ENDCASES,
			      pending: putstack(len, G, s)(St)(n1)
			      ENDCASES),
	    choice(n1, n2): (CASES scaf(pos)(n1) OF
	                      fail: CASES scaf(pos)(n2) OF
			                   fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest],
					   loop : St WITH [`scaf(pos)(cur) := loop, `stack := rest],
					   good(sp): St WITH [`scaf(pos)(cur) := good(sp), `stack := rest],
					   pending: putstack(len, G, s)(St)(n2)
					ENDCASES,
			      loop: St WITH [`scaf(pos)(cur) := loop, `stack := rest],
			      good(sp): St WITH [`scaf(pos)(cur) := good(sp), `stack := rest],
			      pending: putstack(len, G, s)(St)(n1)
			      ENDCASES),
	    check(n1): (CASES scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := fail, `stack := rest],
			      loop: St WITH [`scaf(pos)(cur) := loop, `stack := rest],
			      good(sp): St WITH [`scaf(pos)(cur) := good(0), `stack := rest],
			      pending: putstack(len, G, s)(St)(n1)
			      ENDCASES),
	    neg(n1): (CASES scaf(pos)(n1) OF
	                      fail: St WITH [`scaf(pos)(cur) := good(0), `stack := rest],
			      loop: St WITH [`scaf(pos)(cur) := loop, `stack := rest],
			      good(sp): St WITH [`scaf(pos)(cur) := fail, `stack := rest],
			      pending: putstack(len, G, s)(St)(n1)
			      ENDCASES)
	ENDCASES)
    ENDIF)

IMPORTING lex4, arrayCount


cmember(l: list[non_terminal])(a: non_terminal): bool = member(a, l)

membership_update: LEMMA
   (FORALL (a: non_terminal), (l: list[non_terminal]): 
      count(num_non_terminals)(id[bool])(cmember(cons(a, l))) =
      count(num_non_terminals)(id[bool])(cmember(l) WITH [(a) := TRUE]))


size(len, G, (s: strings(len)))(St : state(len, G, s)): ordinal =
  lex4(St`pos, num_non_terminals - St`root,
       count[entry](num_non_terminals)(pending?)(St`scaf(St`pos)),
       num_non_terminals - count[bool](num_non_terminals)(id)(cmember(St`stack)))

size_putstack:
  JUDGEMENT putstack(len, G, (s: strings(len)))(St: state(len, G, s) | NOT null?(St`stack))(n | pending?(St`scaf(St`pos)(n)))
   HAS_TYPE {St1: state(len, G, s) | size(len, G, s)(St1) < size(len, G, s)(St)}

size_step: LEMMA
 FORALL len, G, (s: strings(len)), (St: state(len, G, s)): 
   NOT (St`pos = 0 AND St`root = num_non_terminals)
   IMPLIES size(len, G, s)(step(len, G, s)(St)) < size(len, G, s)(St)

endstate(len, G, (s: strings(len))): TYPE =
  {St: state(len, G, s) | St`pos = 0 AND St`root = num_non_terminals}

parse(len, G, (s: strings(len)))(St : state(len, G, s)): RECURSIVE endstate(len, G, s)
 = (IF St`pos = 0 AND St`root = num_non_terminals
     THEN St
     ELSE parse(len, G, s)(step(len, G, s)(St))
     ENDIF)
     MEASURE size(len, G, s)(St) BY <

doparse(len, G, (s: strings(len)), n): entry
  = (LET St: state(len, G, s) = (# pos := len,
                 root := 0,
		 stack := null,
		 scaf := (LAMBDA (i: upto(len)): (LAMBDA n: pending)) #)
     IN parse(len, G, s)(St)`scaf(0)(n))
       
  END topdown
