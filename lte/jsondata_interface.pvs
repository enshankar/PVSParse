jsondata_interface: THEORY
BEGIN

  IMPORTING jsondata, ltedfapegproof, stringutils, itoa, bsparsenum, bsparsestr

  get_key_rec(kvs: aseq[(jpair?)], key: bstring, i: upto(kvs`length)): RECURSIVE lift[jsondata]
  = IF i = kvs`length THEN bottom
    ELSE IF key(kvs`seq(i)) = key THEN up(value(kvs`seq(i)))
	 ELSE get_key_rec(kvs, key, i+1)
	 ENDIF
    ENDIF
  MEASURE kvs`length - i

  get_key(object: (jdict?), key: bstring): lift[jsondata]
  = get_key_rec(contents(object), key, 0)

  has_key(object: (jdict?), key: bstring): bool =
    EXISTS (i: below(contents(object)`length)): key(contents(object)`seq(i)) = key

  dict: (jdict?) = jdict((# length := 2, seq := [: jpair("foo", jstr("bar")), jpair("abc", jstr("def")) :]#))

  has_key_test1: _TEST_
    has_key(dict, "foo")

  has_key_test2: _TEST_
    has_key(dict, "abc")

  has_key_test3: _TEST_
    NOT has_key(dict, "bar")

  result_type: DATATYPE
  BEGIN
    r_failed(reason: bytestring): r_failed?
    r_success(json: jsondata): r_success?
  END result_type

  parse_string(s: bytestring): result_type =
  LET trimmed_str = trim_str(s) IN
  CASES bs_to_parsed_string(substr(trimmed_str, 1, length(trimmed_str) - 1)) OF
    failed_str(reason): r_failed("failed to parse string \"" ++ trimmed_str ++ "\""),
    success_str(result): r_success(jstr(result))
  ENDCASES

  parse_number(s: bytestring): result_type =
  CASES bs_to_num(trim_str(s)) OF
    failed_num: r_failed("failed to parse number " ++ trim_str(s)),
    success_int(n): r_success(jnumeral(n, 0)),
    success_dec(mantissa, exponent): r_success(jnumeral(mantissa, exponent))
  ENDCASES

  parse_keyword(s: bytestring): result_type =
  CASES bs_to_keyword(trim_str(s)) OF
    keyword_true: r_success(jbool(TRUE)),
    keyword_false: r_success(jbool(FALSE)),
    keyword_null: r_success(jnull),
    failed_keyword: r_failed("failed to parse keyword " ++ trim_str(s))
  ENDCASES

  aseq_reverse(a: aseq[jsondata]): aseq[jsondata] =
    (# length := a`length,
       seq := (LAMBDA (x: below(a`length)): a`seq(a`length - 1 - x)) #)

  ejson_parsetree_to_json(pt: (allgoodentries?)): RECURSIVE result_type =
    CASES pt OF
      zero(nt, ent):
        COND
          % token
          nt = 8 -> parse_string(chars(ent)),
          % digit
          nt = 16 -> parse_number(chars(ent)),
          % keyword
          nt = 33 -> parse_keyword(chars(ent)),
          ELSE -> r_failed("failed to parse zero-element node of type " ++ itoa(nt))
        ENDCOND,
      one(nt, ent, subone): r_failed("single-element node not supported"),
      two(nt, ent, subone, subtwo):
        COND
          % Structural: data(0), digitkeywordtoken(12), tokencolon(10), dictail*(11), keywordtoken (32)
          nt = 0 OR nt = 12 OR nt = 10 OR nt = 11 OR nt = 32 ->
            CASES ejson_parsetree_to_json(subone) OF
              r_failed(r1):
                CASES ejson_parsetree_to_json(subtwo) OF
                  r_failed(r2): r_failed("Failed to parse node of type " ++ itoa(nt) ++ " with reason subone: " ++ r1 ++ ", subtwo: " ++ r2),
                  r_success(json): r_success(json)
                ENDCASES,
              r_success(json): r_success(json)
            ENDCASES,
          % Dictionary:
          % dictdata(1)
          nt = 1 ->
            CASES ejson_parsetree_to_json(subtwo) OF
              r_failed(r): r_failed(r),
              r_success(json): IF jdict?(json) THEN
                r_success(jdict(aseq_reverse(contents(json))))
              ELSE
                r_failed("unexpected non-dict")
              ENDIF
            ENDCASES,
          % dictail(5)
          nt = 5 ->
            CASES ejson_parsetree_to_json(subtwo) OF
              r_failed(r): r_success(jdict(empty_aseq)),
              r_success(json): r_success(json)
            ENDCASES,
          % ndictail(6)
          nt = 6 ->
            % subone = dictentry
            % subtwo = dictail*
            CASES ejson_parsetree_to_json(subone) OF
              r_failed(r): r_failed(r),
              r_success(json_entry: jsondata):
                CASES ejson_parsetree_to_json(subtwo) OF
                  r_failed(r): IF jpair?(json_entry) THEN
                    r_success(jdict((# length := 1, seq := [: json_entry :] #)))
                  ELSE
                    r_failed(r)
                  ENDIF,
                  r_success(json_rest: jsondata):
                    IF jpair?(json_entry) AND jdict?(json_rest) THEN
                        r_success(jdict(aseq_add(json_entry, contents(json_rest))))
                    ELSE
                        r_failed("bad subtypes in dictionary")
                    ENDIF
                ENDCASES
            ENDCASES,
          % dictentry(7)
          nt = 7 -> LET
            key = ejson_parsetree_to_json(subone),
            value = ejson_parsetree_to_json(subtwo)
          IN
            IF r_success?(key) AND jstr?(json(key)) AND r_success?(value) THEN
              r_success(jpair(strval(json(key)), json(value)))
            ELSE
              IF r_failed?(key) THEN
                r_failed("failed to extract key: " ++ reason(key))
              ELSIF r_failed?(value) THEN
                r_failed("failed to extract value: " ++ reason(value))
              ELSE
                r_failed("key not string(?)")
              ENDIF
            ENDIF,
          % Array
          % adata (2)
          nt = 2 ->
            CASES ejson_parsetree_to_json(subtwo) OF
              r_failed(r): r_failed(r),
              r_success(json): IF jarray?(json) THEN
                r_success(jarray(aseq_reverse(arrval(json))))
              ELSE
                r_failed("unexpected non-array")
              ENDIF
            ENDCASES,
          % arraydata*(13), commaarraydata*(14)
          nt = 13 OR nt = 14 ->
            CASES ejson_parsetree_to_json(subtwo) OF
              r_failed(r): r_success(jarray(empty_aseq)),
              r_success(json): r_success(json)
            ENDCASES,
          % arraydatadata*(15)
          nt = 15 ->
            LET
              car = ejson_parsetree_to_json(subone),
              cdr = ejson_parsetree_to_json(subtwo)
            IN
              IF r_success?(car) AND r_success?(cdr) AND jarray?(json(cdr)) THEN
                r_success(jarray(aseq_add(json(car), arrval(json(cdr)))))
              ELSIF r_success?(car) THEN
                r_success(jarray((# length := 1, seq := [: json(car) :] #)))
              ELSE
                r_failed("failed to extract array elements")
              ENDIF,
           ELSE -> r_failed("unknown node type")
        ENDCOND
    ENDCASES
  MEASURE pt by <<

  IMPORTING ltedfapegtest

  json_from_str(s: bytestring): result_type =
    LET ast = json_ast_from_str(s) IN
      IF allgoodentries?(ast) THEN
        ejson_parsetree_to_json(ast)
      ELSE
        r_failed("Parse failure")
      ENDIF

  do_test(fname: string): result_type =
    LET ast = jsonbuildast(mk_bytestring("test_files/") ++ fname) IN
      IF allgoodentries?(ast) THEN
        ejson_parsetree_to_json(ast)
      ELSE
        r_failed("not all good entries")
      ENDIF

  check_test(result: result_type, expected: jsondata): bool = IF r_failed?(result) THEN FALSE ELSE json(result) = expected ENDIF

  trivial_json: result_type = do_test("trivial.json")
  trivial_result: jsondata = jdict(empty_aseq)
  trivial_test: _TEST_ check_test(trivial_json, trivial_result)

  trivial_array_json: result_type = do_test("trivial_array.json")
  trivial_array_result: jsondata = jarray(empty_aseq)
  trivial_array_test: _TEST_ check_test(trivial_array_json, trivial_array_result)

  trivial_num_json: result_type = do_test("trivial_num.json")
  trivial_num_result: jsondata = jnumeral(3, 0)
  trivial_num_test: _TEST_ check_test(trivial_num_json, trivial_num_result)

  trivial_string_json: result_type = do_test("trivial_string.json")
  trivial_string_result: jsondata = jstr("foo")
  trivial_string_test: _TEST_ check_test(trivial_string_json, trivial_string_result)

  test_json: result_type = do_test("test.json")
  test_result: jsondata =
    jdict((# length := 3,
             seq := [:
               jpair(mk_bytestring("foo"),
                         jnumeral(1, 0)),
    	       jpair(mk_bytestring("bar"),
    	             jstr(mk_bytestring("bar"))),
    	       jpair(mk_bytestring("quux"),
    	             jdict((# length := 2,
    		              seq := [:
                            jpair(mk_bytestring("bar1"),
    				              jstr(mk_bytestring("bar1"))),
                            jpair(mk_bytestring("foo1"),
    				              jnumeral(1, 0))
    		                     :]
    	                    #)))
    	    :]
          #))
  test_test: _TEST_ check_test(test_json, test_result)

  test_ws_min_json: result_type = do_test("test_ws_min.json")
  test_ws_min_test: _TEST_ check_test(test_ws_min_json, test_result)
  test_ws_max_json: result_type = do_test("test_ws_max.json")
  test_ws_max_test: _TEST_ check_test(test_ws_max_json, test_result)

  test1_json: result_type = do_test("test1.json")
  test1_result: jsondata =
    jdict((# length := 1,
             seq := [:
               jpair("foo", jstr("bar"))
                     :] #))
  test1_test: _TEST_ check_test(test1_json, test1_result)

  test2_json: result_type = do_test("test2.json")
  test2_result: jsondata =
    jdict((# length := 2,
             seq := [:
               jpair("foo", jstr("bar")),
               jpair("baz", jstr("quux"))
                     :] #))
  test2_test: _TEST_ check_test(test2_json, test2_result)

  test3_json: result_type = do_test("test3.json")
  test3_result: jsondata =
    jdict((# length := 3,
             seq := [:
               jpair("foo", jstr("bar")),
               jpair("baz", jstr("quux")),
               jpair("ping", jstr("pong"))
                     :] #))
  test3_test: _TEST_ check_test(test3_json, test3_result)

  test4_json: result_type = do_test("test4.json")
  test4_result: jsondata =
    jdict((# length := 4,
             seq := [:
               jpair("foo", jstr("bar")),
               jpair("baz", jstr("quux")),
               jpair("ping", jstr("pong")),
               jpair("wing", jstr("ding"))
                     :] #))
  test4_test: _TEST_ check_test(test4_json, test4_result)

  test5_json: result_type = do_test("test5.json")
  test5_result: jsondata =
    jarray((# length := 5,
              seq := [:
                jnumeral(1, 0),
                jnumeral(2, 0),
                jnumeral(3, 0),
                jnumeral(4, 0),
                jnumeral(5, 0)
              :] #))
  test5_test: _TEST_ check_test(test5_json, test5_result)

  test6_json: result_type = do_test("test6.json")
  test6_result: jsondata =
    jdict((# length := 1,
             seq := [:
               jpair("foo", jnumeral(3, 0))
             :] #))
  test6_test: _TEST_ check_test(test6_json, test6_result)

  test7_json: result_type = do_test("test7.json")
  test7_result: jsondata = jbool(FALSE)

  test7_test: _TEST_ check_test(test7_json, test7_result)

  test8_json: result_type = do_test("test8.json")
  test8_result: jsondata =
    jdict((# length := 3,
             seq := [:
               jpair("true", jbool(TRUE)),
               jpair("false", jbool(FALSE)),
               jpair("null", jnull)
             :] #))
  test8_test: _TEST_ check_test(test8_json, test8_result)

  test9_json: result_type = do_test("test9.json")
  test9_result: jsondata =
    jdict((# length := 3,
             seq := [:
               jpair("100", jnumeral(1, 2)),
               jpair("-349", jnumeral(-349, 0)),
               jpair("1.1", jnumeral(11, -1))
             :] #))
  test9_test: _TEST_ check_test(test9_json, test9_result)

END jsondata_interface
