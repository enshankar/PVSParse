stringutils: THEORY
BEGIN

  digit(x: byte): bool = (x >= 48 AND x <= 57)
  any(x: byte): bool = TRUE
  whitespace(x: byte): bool = (x = 32 OR (x >= 9 AND x <= 13))

  is_quote(b: byte): bool = b = 34
  is_backslash(b: byte): bool = b = 92
  is_slash(b: byte): bool = b = 47
  is_t(x: byte): bool = (x = 116)
  is_r(x: byte): bool = (x = 114)
  is_f(x: byte): bool = (x = 102)
  is_n(x: byte): bool = (x = 110)
  is_b(x: byte): bool = (x = 98)
  is_dot(x: byte): bool = (x = 46)
  is_eE(x: byte): bool = (x = 69 OR x = 101)
  is_plus(x: byte): bool = (x = 43)
  is_minus(x: byte): bool = (x = 45)
  is_u(x: byte): bool = (x = 117)
  is_e(x: byte): bool = (x = 101)
  is_a(x: byte): bool = (x = 97)
  is_l(x: byte): bool = (x = 108)
  is_s(x: byte): bool = (x = 115)

  escapable(x: byte): bool = (is_quote(x) OR is_backslash(x) OR is_slash(x) OR
                               is_b(x) OR is_f(x) OR is_n(x) OR is_r(x) OR is_t(x))

  escape_convert(b: byte): byte =
  COND
    is_quote(b) -> 34,
    is_backslash(b) -> 92,
    is_slash(b) -> 47,
    is_b(b) -> 8,
    is_t(b) -> 9,
    is_n(b) -> 10,
    is_f(b) -> 12,
    is_r(b) -> 13,
    ELSE -> 0
  ENDCOND

  escape_char(b: byte): bytestring =
  COND
    b = 34 -> (# length := 2, seq := [: 92, 34 :] #),
    b = 92 -> (# length := 2, seq := [: 92, 92 :] #),
    b = 8 -> (# length := 2, seq := [: 92, 98 :] #),
    b = 9 -> (# length := 2, seq := [: 92, 116 :] #),
    b = 10 -> (# length := 2, seq := [: 92, 110 :] #),
    b = 12 -> (# length := 2, seq := [: 92, 102 :] #),
    b = 13 -> (# length := 2, seq := [: 92, 114 :] #),
    ELSE -> (# length := 1, seq := [: b :] #)
  ENDCOND

  % Function to add escape characters to a bytestring for JSON compatibility.
  escape_string_inner(s: bytestring, i: index, acc: bytestring): RECURSIVE bytestring =
    IF i >= length(s) THEN acc
    ELSE
      escape_string_inner(s, i+1, acc ++ escape_char(get(s, i)))
    ENDIF
  MEASURE length(s) - i

  escape_string(s: bytestring): bytestring = escape_string_inner(s, 0, "")

  % Test case 1: Empty string
  % An empty string should remain an empty string.
  escape_string_test_empty: _TEST_ escape_string("") = ""

  % Test case 2: String with no special characters
  % A string with no characters that need escaping should remain unchanged.
  escape_string_test_no_escape: _TEST_ escape_string("hello") = "hello"

  % Test case 3: Single quote character
  % A double quote (") should be escaped to (\").
  escape_string_test_quote: _TEST_
    escape_string((# length := 1, seq := [: 34 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 34 :] #)

  % Test case 4: Single backslash character
  % A backslash (\) should be escaped to (\\).
  escape_string_test_backslash: _TEST_
    escape_string((# length := 1, seq := [: 92 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 92 :] #)

  % Test case 5: Single backspace character
  % A backspace (\b) should be escaped to (\\b).
  escape_string_test_backspace: _TEST_
    escape_string((# length := 1, seq := [: 8 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 98 :] #)

  % Test case 6: Single tab character
  % A tab (\t) should be escaped to (\\t).
  escape_string_test_tab: _TEST_
    escape_string((# length := 1, seq := [: 9 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 116 :] #)

  % Test case 7: Single newline character
  % A newline (\n) should be escaped to (\\n).
  escape_string_test_newline: _TEST_
    escape_string((# length := 1, seq := [: 10 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 110 :] #)

  % Test case 8: Single formfeed character
  % A formfeed (\f) should be escaped to (\\f).
  escape_string_test_formfeed: _TEST_
    escape_string((# length := 1, seq := [: 12 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 102 :] #)

  % Test case 9: Single carriage return character
  % A carriage return (\r) should be escaped to (\\r).
  escape_string_test_carriage_return: _TEST_
    escape_string((# length := 1, seq := [: 13 :] #)) =
    "" ++ (# length := 2, seq := [: 92, 114 :] #)

  % Test case 10: A mixed string with characters that need and don't need escaping.
  % Input: "hi\n\\\""
  escape_string_test_mixed_string: _TEST_
    escape_string((# length := 5, seq := [: 104, 105, 10, 92, 34 :] #)) =
    "" ++ (# length := 8, seq := [: 104, 105, 92, 110, 92, 92, 92, 34 :] #)

  % Test case 11: String containing all special characters
  % Input: "\"\b\t\n\f\r\\"
  escape_string_test_all_special_chars: _TEST_
    escape_string((# length := 7, seq := [: 34, 8, 9, 10, 12, 13, 92 :] #)) =
    "" ++ (# length := 14, seq := [: 92, 34, 92, 98, 92, 116, 92, 110, 92, 102, 92, 114, 92, 92 :] #)

  first_printable_inner(bs: bytestring, i: index): RECURSIVE index =
    IF i = bs`length THEN
      bs`length - 1
    ELSIF NOT whitespace(get(bs, i)) THEN
      i
    ELSE
      first_printable_inner(bs, i+1)
    ENDIF
  MEASURE bs`length - i

  first_printable(bs: bytestring): index =
    first_printable_inner(bs, 0)

  last_printable_inner(bs: bytestring, i: index): RECURSIVE index =
    IF i = 0 THEN
      0
    ELSIF NOT whitespace(get(bs, i-1)) THEN
      i
    ELSE
      last_printable_inner(bs, i-1)
    ENDIF
  MEASURE i

  last_printable(bs: bytestring): index =
    IF bs`length = 0 THEN
      0
    ELSE
      last_printable_inner(bs, length(bs))
    ENDIF

  trim_str(bs: bytestring): bytestring =
    LET start_pos = first_printable(bs),
        end_pos = last_printable(bs)
    IN
      IF bs`length < 1 THEN
        bs
      ELSE
        substr(bs, start_pos, end_pos)
      ENDIF

  trim_str_test0: _TEST_ trim_str(" foo ") = "foo"
  trim_str_test1: _TEST_ trim_str(" ") = ""
  trim_str_test2: _TEST_ trim_str("f o o ") = "f o o"
  trim_str_test3: _TEST_ trim_str("") = ""
  trim_str_test4: _TEST_ trim_str(" foo") = "foo"
  trim_str_test5: _TEST_ trim_str("foo") = "foo"
  trim_str_test6: _TEST_ trim_str("1") = "1"

  join_inner(separator: bytestring, s: aseq[bytestring], i: index, acc: bytestring): RECURSIVE bytestring =
    IF i >= s`length THEN
      acc
    ELSIF i = 0 THEN
      join_inner(separator, s, i+1, s`seq(i))
    ELSE
      join_inner(separator, s, i+1, acc ++ separator ++ s`seq(i))
    ENDIF
  MEASURE s`length - i

  join(separator: bytestring, s: aseq[bytestring]): bytestring = join_inner(separator, s, 0, "")

  join_test0: _TEST_ join(",", empty_aseq) = ""
  join_test1: _TEST_ join(mk_bytestring(","), (# length := 1, seq := [: mk_bytestring("a") :] #)) = "a"
  join_test2: _TEST_ join(mk_bytestring(","), (# length := 2, seq := [: mk_bytestring("a"), mk_bytestring("b") :] #)) = "a,b"
  join_test3: _TEST_ join(mk_bytestring(", "), (# length := 3, seq := [: mk_bytestring("a"), mk_bytestring("b"), mk_bytestring("c") :] #)) = "a, b, c"


END stringutils
